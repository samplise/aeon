/**
 * chuangw: 02/04/2012
 *
 * A high-level event is a conceptual execution of event. The old event model in Mace says the event starts when (1) transport layer processes a received message, (2) Timer goes off, or (3) Asynchronous event handler processes an asynchronous message. An event ends when the event handler finishes the processing. 
 *
 * In Full Context model, events are created by the head of virtual node. The head assigns a globally unique event id to the event, and routes the event to the physical node based on the context of the event. 
 * The reason for having a high-level event in addition to the existing low-level event is that a high-level event is composed of several low-level events. Low level events starts and ends on the same physical machine, whereas the conceptual, high-level event, because it can transition to different contexts during the execution, it is likely the execution of the event spans across many physical nodes.
 *
 * */
#ifndef _MACE_HIGHLEVELEVENT_H
#define _MACE_HIGHLEVELEVENT_H
// include system library header
#include <pthread.h>
// include mace library header
#include "mace-macros.h"
#include "Serializable.h"
#include "ScopedLock.h"
#include "mlist.h"
#include "mvector.h"
#include "Serializable.h"
#include "Printable.h"
#include "Message.h"
#include "Accumulator.h"
#include <boost/shared_ptr.hpp>
namespace mace{


class EventID;
/**
 * This class should only be created by head node.
 *
 * It creates a globally unique event id (because it's only created by head node)
 * 
 * This event class object is supposed to be carried around by messages generated by async/sync/timer calls
 * */
class EventMessageRecord: public PrintPrintable, public Serializable {
public:
  uint8_t sid;
  MaceKey dest;
  mace::string message;
  registration_uid_t rid;
  EventMessageRecord(  ){ }
  EventMessageRecord( uint8_t sid, MaceKey dest, mace::string message, registration_uid_t rid ):
    sid( sid ), dest( dest ), message( message ), rid (rid){}
  void print(std::ostream& out) const {
    out<< "EventMessageRecord(";
    out<< "sid="; mace::printItem(out, &(sid) ); out<<", ";
    out<< "dest="; mace::printItem(out, &(dest) ); out<<", ";
    out<< "message="; mace::printItem(out, &(message) ); out<<", ";
    out<< "rid="; mace::printItem(out, &(rid) );
    out<< ")";
  }
  void printNode(PrintNode& pr, const std::string& name) const {
    mace::PrintNode printer(name, "EventMessageRecord" );
    mace::printItem( printer, "sid", &sid );
    mace::printItem( printer, "dest", &dest );
    mace::printItem( printer, "message", &message );
    mace::printItem( printer, "rid", &rid );
    pr.addChild( printer );
  }
  virtual void serialize(std::string& str) const{
      mace::serialize( str, &sid );
      mace::serialize( str, &dest );
      mace::serialize( str, &message   );
      mace::serialize( str, &rid   );
  }
  virtual int deserialize(std::istream & is) throw (mace::SerializationException){
      int serializedByteSize = 0;
      serializedByteSize += mace::deserialize( is, &sid );
      serializedByteSize += mace::deserialize( is, &dest );
      serializedByteSize += mace::deserialize( is, &message   );
      serializedByteSize += mace::deserialize( is, &rid   );
      return serializedByteSize;
  }
};
#ifdef EVENTREQUEST_USE_SHARED_PTR
  typedef boost::shared_ptr<mace::Message> RequestType ;
#else
  typedef mace::Message* RequestType;
#endif
//#define EVENTREQUEST_USE_SHARED_PTR
class EventRequestWrapper: public PrintPrintable, public Serializable {
public:

  uint8_t sid;
  RequestType request;

  EventRequestWrapper(  ): sid( 0 ), request(){ }
  EventRequestWrapper( EventRequestWrapper const& right );
  EventRequestWrapper( uint8_t sid, mace::Message* request ):
    sid( sid ), request( request ){}
  ~EventRequestWrapper();
  mace::EventRequestWrapper & operator=( mace::EventRequestWrapper const& right );
  void print(std::ostream& out) const ;
  void printNode(PrintNode& pr, const std::string& name) const ;
  virtual void serialize(std::string& str) const;
  virtual int deserialize(std::istream & is) throw (mace::SerializationException);
};

class EventUpcallWrapper: public PrintPrintable, public Serializable {
public:

  uint8_t sid;
  mace::Message* upcall;

  EventUpcallWrapper(  ): sid( 0 ), upcall(){ }
  EventUpcallWrapper( EventUpcallWrapper const& right );
  EventUpcallWrapper( uint8_t sid, mace::Message* upcall ):
    sid( sid ), upcall( upcall ){}
  ~EventUpcallWrapper();
  mace::EventUpcallWrapper & operator=( mace::EventUpcallWrapper const& right );
  void print(std::ostream& out) const ;
  void printNode(PrintNode& pr, const std::string& name) const ;
  virtual void serialize(std::string& str) const;
  virtual int deserialize(std::istream & is) throw (mace::SerializationException);
};
class EventSkipRecord: public PrintPrintable, public Serializable {
public:
  uint32_t contextID;
  //uint32_t skipID;
	EventID skipID;
  mace::map< uint32_t, EventSkipRecord >* childContextRecord;

  EventSkipRecord(): contextID(0), skipID(new EventID()), childContextRecord(NULL){}


  EventSkipRecord& operator=(const EventSkipRecord& orig){
    ASSERTMSG( this != &orig, "Self assignment is forbidden!" );
    this->contextID = orig.contextID;
    this->skipID = orig.skipID;
    if( orig.childContextRecord == NULL ){
      this->childContextRecord = NULL;
    }else{
      this->childContextRecord = new mace::map< uint32_t, EventSkipRecord >( *(orig.childContextRecord) );
    }
    return *this;
  }
  EventSkipRecord (const mace::EventSkipRecord& orig) { 
    *this = orig ;
  }

  ~EventSkipRecord(){
    delete childContextRecord;
  }
  EventSkipRecord const& find( uint32_t contextID ) const{
    mace::map<uint32_t, EventSkipRecord>::const_iterator sit = childContextRecord->find( contextID );
    ASSERT( sit != childContextRecord->end() );
    return sit->second;
  }

  EventSkipRecord & operator[]( uint32_t contextID ){
    return (*childContextRecord)[ contextID ];
  }
  void set( const uint32_t contextID, const EventID& eventID ){
    this->contextID = contextID;
    this->skipID = eventID;
  }
  void clear(){
    delete childContextRecord;
  }
  void initChildSkipRecord(){
    childContextRecord = new mace::map< uint32_t, EventSkipRecord >();
  }

  void print(std::ostream& out) const ;
  void printNode(PrintNode& pr, const std::string& name) const ;
  virtual void serialize(std::string& str) const;
  virtual int deserialize(std::istream & is) throw (mace::SerializationException);
  bool operator==( mace::EventSkipRecord const& r2) const{
    if( this->contextID != r2.contextID ) return false;
    if( this->skipID != r2.skipID ) return false;
    if( this->childContextRecord == NULL && r2.childContextRecord == NULL  ) return true;

    if( this->childContextRecord != NULL && r2.childContextRecord != NULL ){
      return *(this->childContextRecord) == *(r2.childContextRecord) ;
    }
    return false;
  }
};
bool operator==( mace::EventMessageRecord const& r1, mace::EventMessageRecord const& r2);
class Event: public PrintPrintable, public Serializable{
public:
    /* chuangw: experiment result from Event_test:
     *  mace::set is much faster than mace::hash_set */
    typedef mace::set< uint32_t > EventServiceContextType;
    typedef mace::map<uint8_t, EventServiceContextType > EventContextType;
    /* chuangw: experiment result from Event_test:
     *  mace::map is much faster than mace::hash_map */
    typedef mace::map< uint32_t, mace::string> EventServiceSnapshotContextType;
    typedef mace::map<uint8_t, EventServiceSnapshotContextType > EventSnapshotContextType;

    //typedef mace::map< uint32_t, uint64_t > EventSkipRecordType;
    typedef EventSkipRecord EventSkipRecordType ;
    typedef mace::map<uint8_t, EventSkipRecordType > SkipRecordType;
    //typedef mace::vector<EventSkipRecordType > SkipRecordType;

    typedef mace::vector< EventRequestWrapper > EventRequestType;
    typedef mace::vector< EventMessageRecord > DeferredMessageType;
    typedef mace::vector< EventUpcallWrapper > DeferredUpcallType;

    /**
     * Default constructor. 
     * Initialize the event ID to zero, and set type to UNDEFEVENT
     * */
    Event():
      eventID ( new EventID() ), 
      eventType ( mace::Event::UNDEFEVENT ) { }
    /* creates a new event */
    Event(const int8_t type): eventType(type), eventContexts( ),eventSnapshotContexts( ){
      newEventID( type);
      initialize( );
    }
    /**
     * Initialize a new event, using the ticket number stored in ThreadStructure::myTicket() 
     * @type the event type
     * 
     * */
    void newEventID( const int8_t type);
    void initialize( ){

        if( !eventContexts.empty() ){
          eventContexts.clear();
        }
        if( !eventSnapshotContexts.empty() ){
          eventSnapshotContexts.clear();
        }

        for( uint32_t n = 0; n< eventSkipID.size(); n++ ){
          eventSkipID[n].clear();
        }
        eventMessages.clear();
        // check if this node is the head node?
        this->eventContextMappingVersion = lastWriteContextMapping;

    }

    /* this constructor creates a copy of the event object */
    Event( const EventID& id, const int8_t type, const EventContextType& contexts, const EventSnapshotContextType& snapshotcontexts, const uint64_t mappingversion, const SkipRecordType& skipID, const DeferredMessageType& messages ):
      eventID( id ),eventType( type ),  eventContexts( contexts ), eventSnapshotContexts( snapshotcontexts ),  eventContextMappingVersion( mappingversion ), eventSkipID( skipID ), eventMessages( messages ){
    }
    /* this constructor creates a lighter copy of the event object.
     * this constructor may be used when only the event ID is used. */
    Event( const EventID& id ):
      eventID( id ),
      eventType( UNDEFEVENT ),
      eventContexts(),
      eventSnapshotContexts(),
      eventContextMappingVersion( 0 )
      { }
    Event& operator=(const Event& orig){
      ASSERTMSG( this != &orig, "Self assignment is forbidden!" );
      eventID = orig.eventID;
      eventType = orig.eventType;
      eventContexts = orig.eventContexts;
      eventSnapshotContexts = orig.eventSnapshotContexts;
      eventContextMappingVersion = orig.eventContextMappingVersion;
      eventSkipID = orig.eventSkipID;
      subevents = orig.subevents;
      eventMessages = orig.eventMessages;
      eventUpcalls = orig.eventUpcalls;
      return *this;
    }

    void print(std::ostream& out) const;
    void printNode(PrintNode& pr, const std::string& name) const;

    const EventID& getEventID() const{
        return eventID;
    }
    const int8_t getEventType() const{
        return eventType;
    }

    void commit() {
      waitToken();
      // create subevents
      if( !subevents.empty() ){
        enqueueDeferredEvents();
      }

      // WC: send deferred messages
      if( !eventMessages.empty() ){
        sendDeferredMessages();
      }
      
      // WC: execute deferred upcalls in the application
      if( !eventUpcalls.empty() ){
        executeApplicationUpcalls();
      }

      // WC: TODO: if this is a migration event, send messages to all physical nodes
      // to clean up the old context-node map.
    }
    virtual void serialize(std::string& str) const{
        mace::serialize( str, &eventType );
        mace::serialize( str, &eventID   );
        // if the eventType is UNDEFEVENT, this event is used in an event request,
        // so the rest of the fields are meaningless.
        if( eventType == UNDEFEVENT )
          return;

        mace::serialize( str, &eventContexts   );
        mace::serialize( str, &eventSnapshotContexts   );
        mace::serialize( str, &eventContextMappingVersion   );
        mace::serialize( str, &eventSkipID   );
        mace::serialize( str, &subevents   );
        mace::serialize( str, &eventMessages   );
        mace::serialize( str, &eventUpcalls   );
    }
    virtual int deserialize(std::istream & is) throw (mace::SerializationException){
        int serializedByteSize = 0;
        serializedByteSize += mace::deserialize( is, &eventType );
        serializedByteSize += mace::deserialize( is, &eventID   );
        // if the eventType is UNDEFEVENT, this event is used in an event request,
        // so the rest of the fields are meaningless.
        if( eventType == UNDEFEVENT )
          return serializedByteSize;

        serializedByteSize += mace::deserialize( is, &eventContexts   );
        serializedByteSize += mace::deserialize( is, &eventSnapshotContexts   );
        serializedByteSize += mace::deserialize( is, &eventContextMappingVersion   );
        serializedByteSize += mace::deserialize( is, &eventSkipID   );
        serializedByteSize += mace::deserialize( is, &subevents   );
        serializedByteSize += mace::deserialize( is, &eventMessages   );
        serializedByteSize += mace::deserialize( is, &eventUpcalls   );
        return serializedByteSize;
    }

    bool deferExternalMessage( uint8_t instanceUniqueID, MaceKey const& dest,  std::string const&  message, registration_uid_t const rid );
    static uint64_t getLastContextMappingVersion( )  {
        // WC: need mutex lock?
        return lastWriteContextMapping;
    }
    void deferEventRequest( uint8_t instanceUniqueID, Message* request){
      subevents.push_back( EventRequestWrapper( instanceUniqueID, request) );
    }
    void clearEventRequests(){
      for( EventRequestType::iterator it = subevents.begin(); it != subevents.end(); it++ ){
        delete it->request;
      }
      subevents.clear();
    }
    void clearEventUpcalls(){
      for( DeferredUpcallType::iterator it = eventUpcalls.begin(); it != eventUpcalls.end(); it++ ){
        delete it->upcall;
      }
      eventUpcalls.clear();
    }
    void deferApplicationUpcalls( uint8_t sid, mace::Message* const& upcall ){
      eventUpcalls.push_back( EventUpcallWrapper(sid, upcall ) );
    }
    static void setLastContextMappingVersion( const EventID& newVersion )  {
         lastWriteContextMapping = newVersion;
    }

    /* set skip id as the event ID. This is conveniently used when the context is created at this event */
    /*void setSkipID(const uint8_t serviceID, const uint32_t contextID, const uint64_t skipID){
      ASSERTMSG( skipID <= eventID , "skipID should be less or equal to eventID");
      eventSkipID[ serviceID ][ contextID ] = skipID;
    }
    void setSkipID(const uint8_t serviceID, const mace::map<uint32_t, uint64_t>& skipIDs){
      eventSkipID[ serviceID ] = skipIDs;
    }*/
    void clearContexts(){
      eventContexts.clear();
    }
    void clearSnapshotContexts(){
      eventSnapshotContexts.clear();
    }
    void clearSkipID(){
      eventSkipID.clear();
    }
    mace::EventSkipRecord& getSkipIDStorage(const uint8_t serviceID){
      /*if( eventSkipID.size() <= serviceID ){
        eventSkipID.resize( serviceID+1 );
      }*/
      return eventSkipID[ serviceID ];
    }

		const EventID& getSkipID(const uint8_t serviceID) {
				ADD_SELECTORS("Event::getSkipID");
				return eventSkipId;
		}

/*  		
    const uint64_t getSkipID(const uint8_t serviceID, const uint32_t contextID, const mace::vector<uint32_t >& parentContextIDs ) const{
      ADD_SELECTORS("Event::getSkipID");
      
      SkipRecordType::const_iterator serv_it = eventSkipID.find( serviceID );
      ASSERTMSG( serv_it != eventSkipID.end(), "skipID not found for this service ID!" );
      EventSkipRecordType const& skipRecords = serv_it->second;

      if( skipRecords.contextID == contextID )
        return skipRecords.skipID;

      // find SkipRecord objects
      // search from the topmost ancestor to the lowest ancestor
      std::vector< EventSkipRecordType const* > records;
      EventSkipRecordType const* nowSkipRecord = &skipRecords;
      //records.push_back( nowSkipRecord );
      for( mace::vector<uint32_t>::const_reverse_iterator pIt = parentContextIDs.rbegin(); pIt != parentContextIDs.rend(); pIt ++ ){
        macedbg(1)<<"pIt is "<<  *pIt <<".";
        if( nowSkipRecord->contextID == *pIt  ){
          macedbg(1)<<" nowSkipRecord->contextID == *pIt."<<Log::endl;
          if( (pIt+1) != parentContextIDs.rend() ){
            macedbg(1)<<" (pIt+1) != parentContextIDs.rend()"<<Log::endl;
            const uint32_t nextContextID = *(pIt+1);
            records.push_back( nowSkipRecord );
            nowSkipRecord = & ( nowSkipRecord->find( nextContextID ) );
          }else{
            macedbg(1)<<" (pIt+1) == parentContextIDs.rend()"<<Log::endl;
            EventSkipRecordType const* temp = & ( nowSkipRecord->find( contextID ) );
            if( temp->skipID != 0 ){
              macedbg(1)<<" temp="<< *temp <<Log::endl;
              return temp->skipID;
            }else{
              macedbg(1)<<"find the context record"<< contextID <<", but it does not have skip id. "<< skipRecords <<", parent contexts are "<< parentContextIDs <<Log::endl;
              records.push_back( nowSkipRecord );
            }
          }
        }else{
          macedbg(1)<<" nowSkipRecord->contextID != *pIt."<<Log::endl;
        }
      }

      macedbg(1)<<"records = (size="<< records.size() << ")";
      for( std::vector< EventSkipRecordType const* >::const_iterator rit = records.begin(); rit != records.end(); rit++){
        macedbg(1)<< (*rit)->contextID <<", ";
      }

      macedbg(1)<<Log::endl;

      mace::vector<uint32_t>::const_iterator pIt = parentContextIDs.begin();
      for( std::vector< EventSkipRecordType const* >::const_reverse_iterator rIt = records.rbegin();
      rIt != records.rend(); rIt++, pIt++ ){
        if( *pIt == (*rIt)->contextID && (*rIt)->skipID != 0 ){
          return (*rIt)->skipID;
        }
      }
      
      ABORT("Why would this happen??");
      return 0;
    }
*/
    void executeApplicationUpcalls();
private:
    void sendDeferredMessages();
    void enqueueDeferredEvents();
    void createToken(){
      // chuangw: create a token which is used by the subevents.
    }
    void waitToken(){
      // chuangw:
      // check if the token has arrived,
      // if so, remove that token from record,
      // otherwise, wait to be unlocked.
    }
    void unlockToken(){
      // chuangw:
      // if an event is waiting at this token, signal it,
      // otherwise, store this token
    }
private:
    static uint64_t nextTicketNumber;
    static EventID lastWriteContextMapping;

public:
    EventID eventId;
    int8_t  eventType;
    EventContextType eventContexts;
    EventSnapshotContextType eventSnapshotContexts;
    uint64_t eventContextMappingVersion;
    SkipRecordType eventSkipID; ///< When this event enters a context, don't wait for event ID less than skipEventID. Each service has its own skipEventID
    //EventID eventSkipId; 
		EventRequestType subevents;
    DeferredMessageType eventMessages;
    DeferredUpcallType eventUpcalls;

    static bool isExit;
    static EventID exitEventId;

    static const int8_t STARTEVENT = 0;
    static const int8_t ENDEVENT   = 1;
    static const int8_t TIMEREVENT = 2;
    static const int8_t ASYNCEVENT = 3;
    static const int8_t UPCALLEVENT= 4;
    static const int8_t DOWNCALLEVENT= 5;
    static const int8_t MIGRATIONEVENT = 6;
    static const int8_t NEWCONTEXTEVENT = 7;
    static const int8_t HEADMIGRATIONEVENT = 8;
    static const int8_t DELETECONTEXT = 9;
    static const int8_t UNDEFEVENT = 10;
};

class EventID: Public Serializable {
public:
		uint32_t create_ctxId;
		uint64_t create_eventId;
		uint32_t execute_ctxId;
		uint64_t execute_eventId;

		uint64_t ctxVerId;

		EventID(): create_ctxId(0), create_eventId(0), execute_ctxId(0), execute_eventId(0), ctxVerId(0) {}
		EventID(uint32_t create_ctxId, uint64_t create_eventId, uint32_t execute_ctxId, uint64_t execute_eventId, uint64_t ctxVerId): 
			create_ctxId(create_ctxId), 
			create_eventId(create_eventId), 
			execute_ctxId(execute_ctxId), 
			execute_eventId(execute_eventId), 
			ctxVerId(ctxVerID){}

		EventID& operator=(const EventID& orig){
    		ASSERTMSG( this != &orig, "Self assignment is forbidden!" );
    		this->create_ctxId = orig.create_ctxId;
    		this->create_eventId = orig.create_eventId;
				this->execute_ctxId = orig.execute_ctxId;
				this->execute_eventId = orig.execute_eventId;
				this->ctxVerId = orig.ctxVerId;
    		return *this;
  	}

		bool operator>(const EventID& e2) {
			if(e2.create_ctxId == this->create_ctxId && this->create_eventId > e2.create_eventId){
				return true;
			}else{
				return false;
			}
		}

		bool operator<(const EventID& e2) {
			if(this->create_ctxId == e2.create_ctxId && this->create_eventId<e2.create_eventId){
				return true;
			}else{
				return false;
			}
		}

		virtual void serialize(std::string& str) const{
        mace::serialize( str, &create_ctxId );
        mace::serialize( str, &create_eventId );
				mace::serialize( str, &execute_ctxId );
				mace::serialize( str, &execute_eventId);
				mace::serialize( str, &ctxVerId);
    }
    virtual int deserialize(std::istream & is) throw (mace::SerializationException){
        int serializedByteSize = 0;
        serializedByteSize += mace::deserialize( is, &create_ctxId );
        serializedByteSize += mace::deserialize( is, &create_enetId );
				serializedByteSize += mace::deserialize( is, &execute_ctxId );
				serializedByteSize += mace::deserialize( is, &execute_eventId );
        return serializedByteSize;
    }
};

}
#endif
