
#define BOOST_TEST_DYN_LINK
#define BOOST_TEST_MODULE libmace
#include <boost/test/unit_test.hpp>
#include "ContextBaseClass.h"
#include "ThreadStructure.h"

/* emulate the context class auto-generated by mace compiler */
class ChildCtx: public mace::ContextBaseClass{
public:
  ChildCtx(const mace::string& contextName="(unnamed)", const uint64_t ticket = 1, const uint8_t serviceID = 0, const uint32_t contextID = 0, const mace::vector< uint32_t >& parentID = mace::vector< uint32_t >(), const uint8_t contextType = CONTEXT ):
  mace::ContextBaseClass(contextName, ticket, serviceID, contextID, parentID, contextType) { }
  ChildCtx( const ChildCtx& _ctx ) : v(_ctx.v) { }
  uint32_t v;
  void snapshot( const uint64_t& ver ) const {
    ChildCtx* _ctx = new ChildCtx(*this);
    mace::ContextBaseClass::snapshot( ver, _ctx );
  }
  const ChildCtx& getSnapshot() const {
    return static_cast< const ChildCtx& >(  mace::ContextBaseClass::getSnapshot()  );
  }
  void setSnapshot(const uint64_t ver, const mace::string& snapshot){
    std::istringstream in( snapshot );
    ChildCtx *obj = new ChildCtx (this->contextName,1  );
    mace::deserialize(in, obj);
    versionMap.push_back( std::make_pair(ver, obj) );
  }
  void serialize(std::string& __str) const {
    mace::serialize(__str, &v);
  }
  int deserialize(std::istream& __in)  throw (mace::SerializationException){
    int serializedByteSize = 0;
    serializedByteSize += mace::deserialize(__in, &v);
    return serializedByteSize;
  }
};
BOOST_AUTO_TEST_SUITE( lib_ContextBaseClass )

BOOST_AUTO_TEST_CASE( CreateDeleteContextClass )
{
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass("Test",1);

  delete ctx;
}

//-----------------------------------------------------------------
BOOST_AUTO_TEST_SUITE( Snapshot )
BOOST_AUTO_TEST_CASE( Test1 )
{
  uint64_t ticket = 1;
  uint64_t event = 1;
  ThreadStructure::setTicket( ticket );
  ThreadStructure::setEvent( event );
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass("Test",event);
  ctx->snapshot( event );
  ctx->snapshotRelease( event );
  delete ctx;
}
BOOST_AUTO_TEST_CASE( Test2 )
{
  uint64_t ticket = 1;
  uint64_t event = 1;
  ThreadStructure::setTicket( ticket );
  ThreadStructure::setEvent( event );
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass("Test",event);
  ctx->snapshot( event );
  ctx->getSnapshot();
  ctx->snapshotRelease( event );

  delete ctx;

}
BOOST_AUTO_TEST_CASE( Test3 )
{
  uint64_t ticket = 1;
  uint64_t event = 1;
  ThreadStructure::setTicket( ticket );
  ThreadStructure::setEvent( event );
  ChildCtx* ctx = new ChildCtx("Test.Child",event);
  ctx->v = 5566;
  ctx->snapshot( event );
  ctx->v = 520;
  const ChildCtx& ctxSnapshot = ctx->getSnapshot();
  BOOST_REQUIRE_EQUAL( ctxSnapshot.v, (uint64_t)5566 );
  ctx->snapshotRelease( event );

  delete ctx;
}
/* stress test */
BOOST_AUTO_TEST_CASE( Test4 )
{
  uint64_t ticket = 1;
  uint64_t event = 1;
  ThreadStructure::setTicket( ticket );
  ChildCtx* ctx = new ChildCtx("Test.Child",event);
  for( event = 1; event <= 1000; event++ ){
    ThreadStructure::setEvent( event );
    ctx->v = event;
    ctx->snapshot( event );
  }
  for( event = 1; event <= 1000; event++ ){
    ThreadStructure::setEvent( event );
    const ChildCtx& ctxSnapshot = ctx->getSnapshot();
    BOOST_REQUIRE_EQUAL( ctxSnapshot.v, event );
    ctx->snapshotRelease( event );
  }

  delete ctx;
}
/* TODO: test ContextLock snapshot correctness when downgrading */

BOOST_AUTO_TEST_SUITE_END()
//-----------------------------------------------------------------
BOOST_AUTO_TEST_SUITE( Serialization )
BOOST_AUTO_TEST_CASE( Test1 )
{
  uint64_t event = 1;
  ChildCtx* ctx = new ChildCtx("Test.Child",event);
  ctx->v = 5566;
  std::string s;
  mace::serialize( s, ctx );
  ctx->v = 0;
  mace::deserialize(s, ctx );

  BOOST_REQUIRE_EQUAL( ctx->v, (uint64_t)5566 );

  delete ctx;
}

BOOST_AUTO_TEST_SUITE_END()
//-----------------------------------------------------------------
BOOST_AUTO_TEST_SUITE( ContextHierarchy )
BOOST_AUTO_TEST_CASE( Test1 )
{
  uint64_t event = 1;
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass("",event);
  delete ctx;
  mace::ContextBaseClass* ctx2 = new mace::ContextBaseClass("A",event);
  delete ctx2;

  mace::ContextBaseClass* ctx3 = new mace::ContextBaseClass("A[0]",event);
  delete ctx3;

  mace::ContextBaseClass* ctx4 = new mace::ContextBaseClass("A[0,1]",event);
  delete ctx4;

  mace::ContextBaseClass* ctx5 = new mace::ContextBaseClass("A[0].B[1]",event);

  delete ctx5;
}
BOOST_AUTO_TEST_CASE( Test2 )
{
  uint8_t serviceID = 0;
  uint32_t contextID = 1;
  uint64_t eventID = 1;
  mace::string contextName = "";
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass( contextName, eventID, serviceID, contextID );

  BOOST_REQUIRE( ctx->getID() == contextID );
  BOOST_REQUIRE( ctx->getName() == contextName );
}
/*BOOST_AUTO_TEST_CASE( Test2 )
{
  uint64_t event = 1;
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass("",event);
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "" ) );
  BOOST_REQUIRE(  ctx->isImmediateParentOf( "A" ) );
  BOOST_REQUIRE(  ctx->isImmediateParentOf( "A[0]" ) );
  BOOST_REQUIRE(  ctx->isImmediateParentOf( "A[0,1]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1].C" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1].D[0]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1].E[0,1]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1].E[0,1].F" ) );
  delete ctx;

  ctx = new mace::ContextBaseClass("A[0].B[1]",event);
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[1]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1]" ) );
  BOOST_REQUIRE(  ctx->isImmediateParentOf( "A[0].B[1].C" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[0].C" ) );
  BOOST_REQUIRE(  ctx->isImmediateParentOf( "A[0].B[1].D[0]" ) );
  BOOST_REQUIRE(  ctx->isImmediateParentOf( "A[0].B[1].E[0,1]" ) );
  BOOST_REQUIRE( !ctx->isImmediateParentOf( "A[0].B[1].E[0,1].F" ) );
  delete ctx;

}
*/
/*BOOST_AUTO_TEST_CASE( Test3 )
{
  uint64_t event = 1;
  mace::ContextBaseClass* ctx = new mace::ContextBaseClass("",event);
  BOOST_REQUIRE( ctx->isLocalCommittable() );
  delete ctx;
}*/
// TODO: ensure that child context set is not altered by the latter events.
BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE_END()
