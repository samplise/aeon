/*
 * bsang: Silo in-memory database application. This application is used to show the consistence and elasticity of our programming
 * model 
 */

#include "m_map.h"
#include "marray.h"
#include "MaceTypes.h" 
#include "RandomUtil.h"

service TreeTPCCAppServer;
provides Null;


services {
  Transport t;
}

typedefs {
  typedef mace::array<Order_Index_Entry, N_MAX_KEY_ENTRY> EntryArray;
}

auto_types {
  WarehouseTableEntry __attribute((comparable(equals=default; lessthan=default))) {
    int32_t w_id;
    mace::string w_name;
    mace::string w_street_1;
    mace::string w_street_2;
    mace::string w_city;
    mace::string w_state;
    mace::string w_zip;
    float w_ytd;
    float w_tax;
  }

  DistrictTableEntry __attribute((comparable(equals=default; lessthan=default))) {
    int32_t d_w_id;
    int32_t d_id;
    float d_ytd;
    float d_tax;
    int32_t d_next_o_id;
    mace::string d_name;
    mace::string d_street_1;
    mace::string d_street_2;
    mace::string d_city;
    mace::string d_state;
    mace::string d_zip;
  }

  CustomerTableEntry __attribute((comparable(equals=default; lessthan=default))) {
    int32_t c_w_id;
    int32_t c_d_id;
    int32_t c_id;
    float c_discount;
    mace::string c_credit;
    mace::string c_last;
    mace::string c_first;
    float c_credit_lim;
    float c_balance;
    float c_ytd_payment;
    int32_t c_payment_cnt;
    int32_t c_delivery_cnt;
    mace::string c_street_1;
    mace::string c_street_2;
    mace::string c_city;
    mace::string c_state;
    mace::string c_zip;
    mace::string c_phone;
    uint32_t c_since;
    mace::string c_middle;
    mace::string c_data;
  }

  NewOrderTableEntry __attribute((comparable(equals=default; lessthan=default))) {
    int32_t no_w_id;
    int32_t no_d_id;
    int32_t no_o_id;
  }

  OrderTableEntry __attribute((comparable(equals=default; lessthan=default))) {
    int32_t o_w_id;
    int32_t o_d_id;
    int32_t o_id;
    int32_t o_c_id;
    int32_t o_carrier_id;
    int16_t o_ol_cnt;
    bool o_all_local;
    uint32_t o_entry_d;
  }

  OrderLineTableEntry __attribute((comparable(equals=default; lessthan=default))) {
    int32_t ol_w_id;
    int32_t ol_d_id;
    int32_t ol_o_id;
    int32_t ol_number;
    int32_t ol_i_id;
    uint32_t ol_delivery_d;
    float ol_amount;
    int32_t ol_supply_w_id;
    int16_t ol_quantity;
  }

  ItemTableEntry __attribute((comparable(equals=default; lessthan=default))) {
    int32_t s_w_id;
    int32_t s_i_id;
    // int16_t s_quantity;
    mace::string s_dist_01;
    mace::string s_dist_02;
    mace::string s_dist_03;
    mace::string s_dist_04;
    mace::string s_dist_05;
    mace::string s_dist_06;
    mace::string s_dist_07;
    mace::string s_dist_08;
    mace::string s_dist_09;
    mace::string s_dist_10;
    float s_ytd;
    int32_t s_order_cnt;
    int32_t s_remote_cnt;
    mace::string s_data;

    int32_t i_id;
    mace::string i_name;
    float i_price;
    mace::string i_data;
    int32_t i_im_id;
  }

  ItemStockTableEntry __attribute((comparable(equals=default; lessthan=default))) {
    int32_t s_w_id;
    int32_t s_i_id;
    int16_t s_quantity;
  }

  HistoryTableEntry __attribute((comparable(equals=default; lessthan=default))) {
    int32_t h_c_id;
    int32_t h_c_d_id;
    int32_t h_c_w_id;
    int32_t h_d_id;
    int32_t h_w_id;
    mace::string h_date;
    int32_t h_amount;
    mace::string h_data;
  }

  oorder_c_id_idx_key __attribute((comparable(equals=default; lessthan=default))) {
    int32_t o_w_id;
    int32_t o_d_id;
    int32_t o_c_id;
    int32_t o_o_id;    
  }

  oorder_c_id_idx_value __attribute((comparable(equals=default; lessthan=default))) {
    bool valid;
    uint8_t o_dummy;
  }

  // The New-Order Transaction
  NewOrderItemStock __attribute((comparable(equals=default; lessthan=default))) {
    int16_t s_quantity;
    mace::string s_dist_01;
    mace::string s_dist_02;
    mace::string s_dist_03;
    mace::string s_dist_04;
    mace::string s_dist_05;
    mace::string s_dist_06;
    mace::string s_dist_07;
    mace::string s_dist_08;
    mace::string s_dist_09;
    mace::string s_dist_10;
    mace::string s_data;

    int32_t i_id;
    float i_price;
  }

  NewOrderDistrict __attribute((comparable(equals=default; lessthan=default))) {
    int32_t d_id;
    float d_tax;
    int32_t d_next_o_id;
  }

  NewOrderWarehouse __attribute((comparable(equals=default; lessthan=default))) {
    int32_t w_id;
    float w_tax;
    mace::vector<NewOrderItemStock> items;
  }

  NewOrderCustomer __attribute((comparable(equals=default; lessthan=default))) {
    int32_t c_id;
    float c_discount;
    mace::string c_last;
    mace::string c_credit;
  }

  NewOrderCustomerReturnValue __attribute((comparable(equals=default; lessthan=default))) {
    int32_t c_id;
    int32_t o_id;
    uint32_t coId;
    bool is_new_order_context;
  }

  // The Payment transaction
  PaymentWarehouse __attribute((comparable(equals=default; lessthan=default))) {
    int32_t w_id;
    mace::string w_name;
    mace::string w_street_1;
    mace::string w_street_2;
    mace::string w_city;
    mace::string w_state;
    mace::string w_zip;
  }

  PaymentDistrict __attribute((comparable(equals=default; lessthan=default))) {
    int32_t d_id;
    mace::string d_name;
    mace::string d_street_1;
    mace::string d_street_2;
    mace::string d_city;
    mace::string d_state;
    mace::string d_zip;
  }

  PaymentCustomer __attribute((comparable(equals=default; lessthan=default))) {
    int32_t c_id;
    float c_discount;
    mace::string c_credit;
    mace::string c_last;
    mace::string c_first;
    float c_credit_lim;
    float c_balance;
    mace::string c_street_1;
    mace::string c_street_2;
    mace::string c_city;
    mace::string c_state;
    mace::string c_zip;
    mace::string c_phone;
    uint32_t c_since;
    mace::string c_middle;
  }

  // The Order-Status Transaction
  OrderStatusCustomer __attribute((comparable(equals=default; lessthan=default))) {
    int32_t c_id;
    mace::string c_last;
    mace::string c_first;
    float c_balance;
    mace::string c_middle;
  }

  OrderStatusOrderLine __attribute((comparable(equals=default; lessthan=default))) {
    int32_t ol_o_id;
    int32_t ol_i_id;
    uint32_t ol_delivery_d;
    float ol_amount;
    int32_t ol_supply_w_id;
    int8_t ol_quantity;
  }

  // The Delivery Transaction
  DeliveryOrder __attribute((comparable(equals=default; lessthan=default))) {
    int32_t o_id;
    int32_t o_c_id;
    uint32_t ol_total;
  }

  // The Stock-Level Transaction
  RangeOrderInfo __attribute((comparable(equals=default; lessthan=default))) {
    int32_t o_id;
    int32_t c_id;
  }

  // Index
  C_Last_Index_Entry __attribute((comparable(equals=default; lessthan=default))) {
    int32_t c_id;
    mace::string c_last;
    mace::string c_first;
  }

  Order_Index_Entry __attribute((comparable(equals=default; lessthan=default))) {
    int32_t o_id;
    int32_t c_id;

    int32_t l_node;
    int32_t r_node;
  }

  Order_Index_Node __attribute((comparable(equals=default; lessthan=default))) {
    int32_t p_node;
    EntryArray keys;
    uint32_t size;
  }
}

constants {
  uint64_t N_KEY_PER_NODE = 100;
  uint64_t N_MAX_KEY_ENTRY = 105;
}

constructor_parameters {
  uint64_t N_WAREHOUSE = 1; 
  uint64_t N_DISTRICT_PER_WAREHOUSE = 10; 
  uint64_t N_CUSTOMER_PER_DISTRICT = 3000; 
  uint64_t N_CUSTOMER_TABLE_PER_DISTRICT = 300; 
  uint64_t N_ITEM = 100000; 
  uint64_t N_ITEMSTOCK_TABLE_PER_WAREHOUSE = 1000; 
      
  uint64_t OUTPUT_COUNT = 50;
}

#minclude "TreeTPCCAppMessages.mi"
 
state_variables {

  context WarehouseTable<uint32_t cwId> { 
    mace::vector<WarehouseTableEntry> warehouseTableEntries;
    mace::vector<ItemTableEntry> itemTableEntries;
    
    int32_t current_d_id;

    uint64_t reqCount;
    uint64_t newOrderReqCount;
    uint64_t paymentReqCount;
    uint64_t orderStatusReqCount;
    uint64_t deliveryReqCount;
    uint64_t stockLevelReqCount; 

    mace::vector<uint32_t> districtTables;
    mace::vector<uint32_t> itemStockTables; 
  }

  context ItemStockTable<uint32_t ciId> {
    mace::map<uint32_t, ItemStockTableEntry> tableEntries;
  }

  context DistrictTable<uint32_t cdId> {
    mace::vector<DistrictTableEntry> tableEntries;

    mace::vector<uint32_t> customerTables;
    mace::map<uint32_t, uint32_t> orderCustomerMap;

    mace::map< mace::string, mace::set<C_Last_Index_Entry> > c_last_idx;

    int32_t oldestNewOrderId;
  }

  context CustomerTable<uint32_t ccId> {
    mace::vector<CustomerTableEntry> tableEntries;
  }

  context HistoryTable<uint32_t chId> {
    mace::vector<HistoryTableEntry> tableEntries;
  }

  context OrderTable<uint32_t coId> {
    mace::vector<OrderTableEntry> tableEntries;

    mace::map<uint32_t, uint32_t> orderLineCtxIdMap;
    mace::map<uint32_t, uint32_t> newOrderCtxIdMap;
  }

  context OrderLineTable<uint32_t colId> {
    mace::vector<OrderLineTableEntry> tableEntries;

  }

  context NewOrderTable<uint32_t cnoId> {
    mace::vector<NewOrderTableEntry> tableEntries;
  }
  
}

transitions {

downcall maceInit() {
  ADD_SELECTORS("TreeTPCCAppServer");
  maceout << "To start TreeTPCCAppServer!" << Log::endl;

  for(uint32_t i=0; i<N_WAREHOUSE; i++ ) {
    uint32_t cwId = createNewContext("WarehouseTable");
    mace::string childCtxName = generateContextName("WarehouseTable", cwId);
    createNewOwnership( "globalContext", childCtxName );

    async_initWarehouseTable( cwId );
  }
}

// Database initialization
async [WarehouseTable<w_id>] initWarehouseTable( const uint32_t& w_id ) {
  ADD_SELECTORS("TreeTPCCAppServer");
  WarehouseTableEntry w_entry(  w_id, 
                              generateRandomString(10), 
                              generateRandomString(20), 
                              generateRandomString(20), 
                              generateRandomString(20), 
                              generateRandomString(2), 
                              generateRandomString(9), 
                              3000000, 
                              (RandomUtil::randInt(10)+10)/100 );

  warehouseTableEntries.push_back(w_entry);

  mace::string myCtxName = generateContextName("WarehouseTable", w_id);
  for(uint32_t i=1; i<=N_DISTRICT_PER_WAREHOUSE; i++ ) {
    uint32_t dt_id = createNewContext("DistrictTable");
    mace::string childCtxName = generateContextName("DistrictTable", dt_id);
    createNewOwnership( myCtxName, childCtxName );

    districtTables.push_back(dt_id);

    async_initDistrictTable( dt_id, w_id, i );
  }

  mace::map< uint32_t, mace::vector<int32_t> > i_ids;

  for( uint32_t i=1; i<=N_ITEMSTOCK_TABLE_PER_WAREHOUSE; i++ ) {
    uint32_t istId = createNewContext("ItemStockTable");
    mace::string childCtxName = generateContextName("ItemStockTable", istId);
    createNewOwnership( myCtxName, childCtxName );

    itemStockTables.push_back( istId );
  }

  mace::map< uint32_t, mace::vector<uint32_t> > item_ids;

  for(uint32_t i=1; i<=N_ITEM; i++ ) {
    ItemTableEntry i_entry(  w_id,  
                                  i,  
                                  generateRandomString(24),  
                                  generateRandomString(24),  
                                  generateRandomString(24),  
                                  generateRandomString(24),  
                                  generateRandomString(24),  
                                  generateRandomString(24),  
                                  generateRandomString(24),  
                                  generateRandomString(24),  
                                  generateRandomString(24),  
                                  generateRandomString(24),  
                                  0, 
                                  0, 
                                  0, 
                                  generateRandomString(50),  
                                  1, 
                                  generateRandomString(16),  
                                  RandomUtil::randInt(100)+1, 
                                  generateRandomString(50), 
                                  100);

    uint32_t iter = i % N_ITEMSTOCK_TABLE_PER_WAREHOUSE;
    uint32_t istId = itemStockTables[iter];
    itemTableEntries.push_back(i_entry);
    item_ids[istId].push_back( i );
  }

  mace::map< uint32_t, mace::vector<uint32_t> >::const_iterator iter;
  for( iter = item_ids.begin(); iter != item_ids.end(); iter++ ) {
    async_initStockTable(iter->first, w_id, iter->second );
  }

  maceout << "To initialize WarehouseTable["<< w_id <<"]!" << Log::endl;
  
  reqCount = 0;
  newOrderReqCount = 0;
  paymentReqCount = 0;
  orderStatusReqCount = 0;
  deliveryReqCount = 0;
  stockLevelReqCount = 0; 
}

async [ItemStockTable<csId>] initStockTable( const uint32_t& csId, const int32_t& w_id, const mace::vector<uint32_t>& item_ids ) {
  ADD_SELECTORS("TreeTPCCAppServer");
  maceout << "To initialize ItemTable["<< csId <<"] with size=" << item_ids.size() << Log::endl;

  for( uint32_t i_iter=0; i_iter<item_ids.size(); i_iter++ ) {
    const uint32_t& i_id = item_ids[i_iter];
    ItemStockTableEntry entry( w_id, i_id, RandomUtil::randInt(90)+10 );
    tableEntries[i_id] = entry;
  }
}

async [DistrictTable<cdId>] initDistrictTable( const uint32_t& cdId, const int32_t& w_id, const int32_t& d_id ) {
  ADD_SELECTORS("TreeTPCCAppServer");
  maceout<< "To initialize DistrictTable["<< cdId <<"] with w_id="<< w_id <<" d_id=" << d_id << Log::endl;

  DistrictTableEntry entry( w_id, 
                            d_id, 
                            30000, 
                            0.02, 
                            1, 
                            generateRandomString(10), 
                            generateRandomString(20), 
                            generateRandomString(20), 
                            generateRandomString(20), 
                            generateRandomString(2), 
                            generateRandomString(9) );

  tableEntries.push_back(entry);
  oldestNewOrderId = 1;
  
  mace::string myCtxName = generateContextName("DistrictTable", cdId);
  mace::map< uint32_t, mace::set<C_Last_Index_Entry> > c_ids;
  
  for( uint32_t i=0; i<N_CUSTOMER_TABLE_PER_DISTRICT; i++ ) {
    uint32_t ccId = createNewContext("CustomerTable");
    mace::string childCtxName = generateContextName("CustomerTable", ccId);
    createNewOwnership( myCtxName, childCtxName );
    customerTables.push_back(ccId);
  }

  for(uint32_t i=1; i<=N_CUSTOMER_PER_DISTRICT; i++ ) {
    uint32_t iter = i % N_CUSTOMER_TABLE_PER_DISTRICT + 1;
    uint32_t ccId = customerTables[iter];
        
    mace::string c_last;

    if( i <=1000 ){
      c_last = Lastname( i-1 );
    } else {
      c_last = Lastname( NURand(255, 0, 999) );
    }
    mace::string c_first = generateRandomString(16);
    C_Last_Index_Entry idx_entry( i, c_last, c_first);
    c_last_idx[c_last].insert(idx_entry);
    c_ids[ccId].insert(idx_entry);
  }

  for( uint32_t i=0; i<customerTables.size(); i++ ) {
    uint32_t ccId = customerTables[i];
    async_initCustomerTable(ccId, w_id, d_id, c_ids[ccId] );
  }
}

async [CustomerTable<ccId>] initCustomerTable( const uint32_t& ccId, const int32_t& w_id, const int32_t& d_id, 
    const mace::set< C_Last_Index_Entry >& c_ids ) {

  ADD_SELECTORS("TreeTPCCAppServer");
  maceout << "To initialize CustomerTable["<< ccId <<"] with w_id=" << w_id << " d_id="<< d_id << " size="<< c_ids.size() << Log::endl;

  mace::set<C_Last_Index_Entry>::const_iterator iter;
  for( iter=c_ids.begin(); iter!=c_ids.end(); iter++ ){
    const C_Last_Index_Entry& e = *iter;

    mace::string c_credit;
    if( RandomUtil::randInt(2) == 1 ){
      c_credit = "G";
    } else {
      c_credit = "B";
    }
    c_credit += "C";
    CustomerTableEntry entry( w_id, 
                              d_id, 
                              e.c_id, 
                              0.05, 
                              c_credit, 
                              e.c_last, 
                              e.c_first, 
                              50000, 
                              -10, 
                              10, 
                              1, 
                              0, 
                              generateRandomString(20), 
                              generateRandomString(20), 
                              generateRandomString(20), 
                              generateRandomString(2), 
                              generateRandomString(9), 
                              generateRandomString(11), 
                              2000, 
                              "OE", 
                              generateRandomString(500) );

    tableEntries.push_back(entry);
  }

  mace::string cCtxName = generateContextName("CustomerTable", ccId);
  mace::string hCtxName = generateContextName("HistoryTable", ccId);
  mace::string oCtxName = generateContextName("OrderTable", ccId);

  createNewOwnership(cCtxName, oCtxName);
  createNewOwnership(cCtxName, hCtxName);
  async_initHistoryTable( ccId );
  async_initOrderTable( ccId );
}

async [HistoryTable<chId>] initHistoryTable( const uint32_t& chId ){
  ADD_SELECTORS("TreeTPCCAppServer");
  maceout << "To initialize HistoryTable["<< chId <<"]!" << Log::endl;
}

async [OrderTable<coId>] initOrderTable( const uint32_t& coId ){
  ADD_SELECTORS("TreeTPCCAppServer");
  maceout << "To initialize OrderTable["<< coId <<"]!" << Log::endl;

  mace::string oCtxName = generateContextName("OrderTable", coId);
  mace::string noCtxName = generateContextName("NewOrderTable", coId);
  mace::string olCtxName = generateContextName("OrderLineTable", coId);

  createNewOwnership(oCtxName, noCtxName);
  createNewOwnership(oCtxName, olCtxName);
  async_initNewOrderTable( coId );
  async_initOrderLineTable( coId );
}

async [NewOrderTable<no_table>] initNewOrderTable( const uint32_t& no_table ){
  ADD_SELECTORS("TreeTPCCAppServer");
  maceout << "To initialize NewOrderTable["<< no_table <<"]!" << Log::endl;
}

async [OrderLineTable<ol_table>] initOrderLineTable( const uint32_t& ol_table ){
  ADD_SELECTORS("TreeTPCCAppServer");
  maceout << "To initialize OrderLineTable["<< ol_table <<"]!" << Log::endl;
}

// The New-Order Transaction
upcall [WarehouseTable<msg.w_id>] deliver( const MaceKey& src, const MaceKey& dest, const NewOrderTransactionMessage& msg ) {
  mace::vector<NewOrderItemStock> items;
  ADD_SELECTORS("TreeTPCCAppServer");
  reqCount ++;
  newOrderReqCount ++;
  if( reqCount % OUTPUT_COUNT == 0 ){
    maceout << "In WarehouseTable["<< msg.w_id <<"] reqCount="<< reqCount << " newOrderReqCount=" << newOrderReqCount << " paymentReqCount=" << paymentReqCount << " orderStatusReqCount=" << orderStatusReqCount << " deliveryReqCount=" << deliveryReqCount << " stockLevelReqCount=" << stockLevelReqCount << Log::endl;
  }

  mace::map< uint32_t, mace::vector<int32_t> > item_ids;
  mace::map< uint32_t, mace::vector<int32_t> > item_quantities;
  for(uint32_t i=0; i<msg.item_ids.size(); i++ ) {
    int32_t itemId = msg.item_ids[i];
    const int32_t& quantity = msg.item_quantities[i];
    
    ItemTableEntry& entry = itemTableEntries[itemId-1];
    
    NewOrderItemStock new_order_item_stock;

    new_order_item_stock.s_quantity = quantity;
    new_order_item_stock.s_dist_01  = entry.s_dist_01;
    new_order_item_stock.s_dist_02  = entry.s_dist_02; 
    new_order_item_stock.s_dist_03  = entry.s_dist_03;
    new_order_item_stock.s_dist_04  = entry.s_dist_04;
    new_order_item_stock.s_dist_05  = entry.s_dist_05;
    new_order_item_stock.s_dist_06  = entry.s_dist_06;
    new_order_item_stock.s_dist_07  = entry.s_dist_06;
    new_order_item_stock.s_dist_08  = entry.s_dist_07;
    new_order_item_stock.s_dist_09  = entry.s_dist_08;
    new_order_item_stock.s_dist_10  = entry.s_dist_09;
    new_order_item_stock.s_data     = entry.s_data;
    new_order_item_stock.i_id       = itemId;

    items.push_back(new_order_item_stock);

    uint32_t iter = itemId % N_ITEMSTOCK_TABLE_PER_WAREHOUSE;
    uint32_t istId = itemStockTables[iter];

    item_ids[ istId ].push_back( itemId );
    item_quantities[ istId ].push_back( quantity );
  }


  for( mace::map< uint32_t, mace::vector<int32_t> >::const_iterator iter=item_ids.begin(); iter!=item_ids.end(); iter++ ){
    async_NewOrderTransactionItemStock( iter->first, iter->second, item_quantities[iter->first] );
  }

  NewOrderWarehouse new_order_warehouse;
  for( uint32_t i=0; i<warehouseTableEntries.size(); i++ ) {
    WarehouseTableEntry& entry = warehouseTableEntries[i];

    if( msg.w_id == entry.w_id ) {
      new_order_warehouse.w_id = entry.w_id;
      new_order_warehouse.w_tax = entry.w_tax;
      break;
    }
  }
  new_order_warehouse.items = items;

  uint32_t d_iter = msg.d_id % N_DISTRICT_PER_WAREHOUSE;
  uint32_t dt_id = districtTables[d_iter];
  async_NewOrderTransactionDistrict(dt_id, msg.d_id, msg.c_id, msg.ol_cnt, new_order_warehouse, src, msg.client_id);
}


async [ItemStockTable<csId>] NewOrderTransactionItemStock( const uint32_t& csId, const mace::vector<int32_t>& i_ids, const mace::vector<int32_t>& quantities ) {
  ADD_SELECTORS("TreeTPCCAppServer");
  
  for( uint32_t j=0; j<i_ids.size(); j++ ){
    const int32_t& i_id = i_ids[j];
    const int32_t& quantity = quantities[j];
    
    ItemStockTableEntry& entry = tableEntries[i_id];
    
    if( entry.s_quantity > quantity ) {
      entry.s_quantity = entry.s_quantity - quantity;
    } else {
      entry.s_quantity = entry.s_quantity - quantity + 91;
    }
  }
}


async [DistrictTable<cdId>] NewOrderTransactionDistrict(const uint32_t& cdId, const int& d_id, const int& c_id, 
    const uint32_t& o_ol_cnt, const NewOrderWarehouse& new_order_warehouse, const MaceKey& src, const uint32_t& clientId) {
  ADD_SELECTORS("TreeTPCCAppServer");
  

  NewOrderDistrict new_order_district;
  for( uint32_t i=0; i<tableEntries.size(); i++ ) {
    DistrictTableEntry& entry = tableEntries[i];

    if( d_id == entry.d_id ) {
      new_order_district.d_id = entry.d_id;
      new_order_district.d_tax = entry.d_tax;
      new_order_district.d_next_o_id = entry.d_next_o_id;

      entry.d_next_o_id ++;
      break;
    }
  }
  uint32_t ct_iter = c_id % N_CUSTOMER_TABLE_PER_DISTRICT;
  uint32_t ct_id = customerTables[ ct_iter ];

  async_NewOrderTransactionCustomer(ct_id, c_id, o_ol_cnt, new_order_warehouse, new_order_district, src, clientId);


  orderCustomerMap[ new_order_district.d_next_o_id ] = c_id;
}

async [CustomerTable<ccId>] NewOrderTransactionCustomer( const uint32_t& ccId, const int& c_id, const uint32_t& o_ol_cnt, 
    const NewOrderWarehouse& new_order_warehouse, const NewOrderDistrict& new_order_district, const MaceKey& src, 
    const uint32_t& clientId) {
  
  ADD_SELECTORS("TreeTPCCAppServer");

  int o_id = new_order_district.d_next_o_id;
  uint32_t o_table = ccId;

  NewOrderCustomer new_order_customer; 
  for( uint32_t i=0; i<tableEntries.size(); i++ ) {
    CustomerTableEntry& entry = tableEntries[i];

    if( c_id == entry.c_id ) {
      new_order_customer.c_id = entry.c_id;
      new_order_customer.c_discount = entry.c_discount;
      new_order_customer.c_last = entry.c_last;
      new_order_customer.c_credit = entry.c_credit;
      break;
    }
  }

  async_NewOrderTransactionOrder(o_table, o_id, o_ol_cnt, new_order_warehouse, new_order_district, new_order_customer, src, clientId);
}

async [OrderTable<coId>] NewOrderTransactionOrder(const uint32_t& coId, const int& o_id, const uint32_t& o_ol_cnt, 
    const NewOrderWarehouse& new_order_warehouse, const NewOrderDistrict& new_order_district, const NewOrderCustomer& new_order_customer, 
    const MaceKey& src, const uint32_t& clientId) {
  ADD_SELECTORS("TreeTPCCAppServer");
    
  OrderTableEntry entry(  new_order_warehouse.w_id,
                          new_order_district.d_id, 
                          o_id, 
                          new_order_customer.c_id,
                          0, 
                          o_ol_cnt,
                          true,
                          100 );

  tableEntries.push_back(entry);
  
  uint32_t no_table = coId;
  async_NewOrderTransactionNewOrder( no_table, o_id, new_order_district.d_id, new_order_warehouse.w_id);

  uint32_t ol_table = coId;
  async_NewOrderTransactionOrderLine( ol_table, o_id, new_order_warehouse, new_order_district, new_order_customer, src, clientId);
}

async [NewOrderTable<cnoId>] NewOrderTransactionNewOrder(const uint32_t& cnoId, const int& no_o_id, const int& no_d_id, const int& no_w_id){
  ADD_SELECTORS("TreeTPCCAppServer");
  NewOrderTableEntry entry( no_w_id, no_d_id, no_o_id );
  tableEntries.push_back(entry);
}

async [OrderLineTable<colId>] NewOrderTransactionOrderLine(const uint32_t& colId, const int& ol_o_id, 
    const NewOrderWarehouse& new_order_warehouse, const NewOrderDistrict& new_order_district, const NewOrderCustomer& new_order_customer, 
    const MaceKey& src, const uint32_t& clientId){
  ADD_SELECTORS("TreeTPCCAppServer");
  
  const mace::vector<NewOrderItemStock>& items = new_order_warehouse.items;

  for(uint32_t ol_number=0; ol_number<items.size(); ol_number++ ){
    const NewOrderItemStock& item = items[ol_number];

    int ol_i_id = item.i_id;
    int ol_quantity = item.s_quantity;

    float ol_amount = ol_quantity * item.i_price * (1+new_order_warehouse.w_tax+new_order_district.d_tax) * (1-new_order_customer.c_discount);

    OrderLineTableEntry entry(  new_order_warehouse.w_id,
                                new_order_district.d_id, 
                                ol_o_id, 
                                ol_number, 
                                ol_i_id,
                                100, 
                                ol_amount,
                                new_order_warehouse.w_id, 
                                ol_quantity );
    tableEntries.push_back(entry);
  }
  if( clientId > 0 ){
    downcall_route(src, RequestReply(clientId, true, new_order_warehouse.w_id, new_order_district.d_id, new_order_district.d_next_o_id) );
  }
}

// The Payment Transaction
upcall [WarehouseTable<msg.w_id>] deliver(const MaceKey& src, const MaceKey& dest, const PaymentTransactionMessage& msg) {
  ADD_SELECTORS("TreeTPCCAppServer");
  reqCount ++;
  paymentReqCount ++;
  if( reqCount % OUTPUT_COUNT == 0 ){
    maceout << "In WarehouseTable["<< msg.w_id <<"] reqCount="<< reqCount << " newOrderReqCount=" << newOrderReqCount 
            << " paymentReqCount=" << paymentReqCount 
            << " orderStatusReqCount=" << orderStatusReqCount << " deliveryReqCount=" << deliveryReqCount 
            << " stockLevelReqCount=" << stockLevelReqCount << Log::endl;
  }
  
  PaymentWarehouse payment_warehouse;
  for( uint32_t i=0; i<warehouseTableEntries.size(); i++ ) {
    WarehouseTableEntry& entry = warehouseTableEntries[i];

    if( msg.w_id == entry.w_id ) {
      entry.w_ytd = entry.w_ytd + msg.h_amount;

      payment_warehouse.w_id = entry.w_id;
      payment_warehouse.w_street_1 = entry.w_street_1;
      payment_warehouse.w_street_2 = entry.w_street_2;
      payment_warehouse.w_city = entry.w_city;
      payment_warehouse.w_state = entry.w_state;
      payment_warehouse.w_zip = entry.w_zip;
      payment_warehouse.w_name = entry.w_name;
      break;
    }
  }

  uint32_t dt_iter = msg.d_id % N_DISTRICT_PER_WAREHOUSE;
  uint32_t dt_id = districtTables[dt_iter];
  async_PaymentTransactionDistrict( dt_id, msg.d_id, msg.c_id, msg.c_last, msg.h_amount, payment_warehouse, src, msg.client_id);
}

async [DistrictTable<cdId>] PaymentTransactionDistrict(const uint32_t& cdId, const int32_t& d_id, const int32_t& c_id, 
    const mace::string& c_last, const int32_t& h_amount, const PaymentWarehouse& payment_warehouse, const MaceKey& src, 
    const uint32_t& clientId) {
  
  ADD_SELECTORS("TreeTPCCAppServer");
  PaymentDistrict payment_district;
  for( uint32_t i=0; i<tableEntries.size(); i++ ) {
    DistrictTableEntry& entry = tableEntries[i];

    if( d_id == entry.d_id ) {
      entry.d_ytd = entry.d_ytd + h_amount;

      payment_district.d_id = entry.d_id;
      payment_district.d_street_1 = entry.d_street_1;
      payment_district.d_street_2 = entry.d_street_2;
      payment_district.d_city = entry.d_city;
      payment_district.d_state = entry.d_state;
      payment_district.d_zip = entry.d_zip;
      payment_district.d_name = entry.d_name;
      break;
    }
  }

  int32_t new_c_id = c_id;
  if( c_last != "" ) {
    int32_t customer_id = getCustomerContextIDByName( c_last, c_last_idx);
    if( customer_id == 0 ) {
      if( clientId > 0){
        downcall_route(src, RequestReply(clientId, false, 0, 0, 0) );
      }
      return;
    }
    new_c_id = customer_id;
  } 
  uint32_t ct_iter = new_c_id % N_CUSTOMER_TABLE_PER_DISTRICT;
  uint32_t ct_id = customerTables[ct_iter];
  
  async_PaymentTransactionCustomer( ct_id, new_c_id, h_amount, payment_warehouse, payment_district, src, clientId);
}

async [CustomerTable<ccId>] PaymentTransactionCustomer(const uint32_t& ccId, const int32_t& c_id, const int32_t& h_amount, 
    const PaymentWarehouse& payment_warehouse, const PaymentDistrict& payment_district, const MaceKey& src, const uint32_t& clientId) {
 
  ADD_SELECTORS("TreeTPCCAppServer");
  PaymentCustomer payment_customer;
  mace::string h_data;
  for( uint32_t i=0; i<tableEntries.size(); i++ ) {
    CustomerTableEntry& entry = tableEntries[i];

    if( c_id == entry.c_id ) {
      payment_customer.c_id = entry.c_id;
      payment_customer.c_first = entry.c_first;
      payment_customer.c_middle = entry.c_middle;
      payment_customer.c_last = entry.c_last;
      payment_customer.c_street_1 = entry.c_street_1;
      payment_customer.c_street_2 = entry.c_street_2;
      payment_customer.c_city = entry.c_city;
      payment_customer.c_state = entry.c_state;
      payment_customer.c_zip = entry.c_zip;
      payment_customer.c_phone = entry.c_phone;
      payment_customer.c_credit = entry.c_credit;
      payment_customer.c_credit_lim = entry.c_credit_lim;
      payment_customer.c_discount = entry.c_discount;
      payment_customer.c_balance = entry.c_balance;
      payment_customer.c_since = entry.c_since;


      int32_t c_balance = h_amount + payment_customer.c_balance;
      if( payment_customer.c_credit == "BC") {
        mace::string c_new_data ="|" + c_id + payment_district.d_id + payment_warehouse.w_id + payment_district.d_id + payment_warehouse.w_id + h_amount;

        entry.c_data = entry.c_data + c_new_data;
      } 
      entry.c_balance = c_balance;

      h_data = payment_warehouse.w_name + '\0' + payment_district.d_name;
      break;
    }
  }

  
  uint32_t chId = ccId;

  async_PaymentTransactionHistory(chId, c_id, payment_district.d_id, payment_warehouse.w_id, payment_district.d_id,  
    payment_warehouse.w_id, "datatime", h_amount, h_data, src, clientId);

}

async [HistoryTable<chId>] PaymentTransactionHistory( const uint32_t& chId, const int32_t h_c_id, const int32_t& h_c_d_id, 
    const int32_t&   h_c_w_id, const int32_t& h_d_id, const int32_t& h_w_id, const mace::string& h_date, const int32_t& h_amount, 
    const mace::string& h_data, const mace::MaceKey& src, const uint32_t& clientId ){
  
  ADD_SELECTORS("TreeTPCCAppServer");
  if( tableEntries.size() == 0 ){
    maceout << "First enter HistoryTable["<< chId <<"]!" << Log::endl;
  }
  HistoryTableEntry entry( h_c_d_id, h_c_w_id, h_c_id, h_d_id, h_w_id, h_date, h_amount, h_data);
  tableEntries.push_back(entry);
  if( clientId > 0){
    downcall_route(src, RequestReply(clientId, false, 0, 0, 0) );
  }
}

// The Order-Status Transaction
upcall [DistrictTable<msg.d_id>] deliver(const MaceKey& src, const MaceKey& dest, const OrderStatusTransactionMessage& msg) {
  int32_t new_c_id = msg.c_id;
  mace::string c_last = msg.c_last;
  uint32_t clientId = msg.client_id;

  if( c_last != "" ) {
    int32_t customer_id = getCustomerContextIDByName( c_last, c_last_idx);
    if( customer_id <= 0 ){
      maceout << "Fail to find c_id for " << c_last <<". To reply directly!"<< Log::endl;
      if( msg.client_id >0 ){
        downcall_route(src, RequestReply(msg.client_id, false, 0, 0, 0) );
      }
      return;
    }
    new_c_id = customer_id;
  }

  uint32_t ct_iter = new_c_id % N_CUSTOMER_TABLE_PER_DISTRICT ;
  uint32_t ct_id = customerTables[ct_iter];  
  
  async_OrderStatusTransactionCustomer( ct_id, new_c_id, src, clientId );
}

async [CustomerTable<ccId>] OrderStatusTransactionCustomer(const uint32_t& ccId, const int32_t& c_id, const MaceKey& src, 
    const uint32_t& clientId) {
  ADD_SELECTORS("TreeTPCCAppServer");

  OrderStatusCustomer order_status_customer;
  for( uint32_t i=0; i<tableEntries.size(); i++ ) {
    CustomerTableEntry& entry = tableEntries[i];

    if( c_id == entry.c_id ) {
      order_status_customer.c_id = entry.c_id;
      order_status_customer.c_balance = entry.c_balance;
      order_status_customer.c_first = entry.c_first;
      order_status_customer.c_middle = entry.c_middle;
      order_status_customer.c_last = entry.c_last;
      break;
    }
  }
  uint32_t coId = ccId;
  async_OrderStatusTransactionOrder(coId, order_status_customer, src, clientId );
}

async [OrderTable<coId>] OrderStatusTransactionOrder( const uint32_t& coId, const OrderStatusCustomer& order_status_customer, 
    const MaceKey& src, const uint32_t& clientId){
  ADD_SELECTORS("TreeTPCCAppServer");

  int32_t o_id = 0;

  for( uint32_t i=0; i<tableEntries.size(); i++ ) {
    OrderTableEntry& entry = tableEntries[i];

    if( order_status_customer.c_id == entry.o_c_id && (o_id == 0 || o_id<entry.o_id) ){
      o_id = entry.o_id;
    }
  }
  if( o_id == 0 ) {
    maceout << "There is no order for customer("<< order_status_customer.c_id <<")! To Reply Client["<< clientId <<"] directly!" << Log::endl;
    if( clientId >0 ){
      downcall_route(src, RequestReply(clientId, false, 0, 0, 0) );
    }
    return;
  }

  uint32_t colId = coId;
  async_OrderStatusTransactionOrderLine( colId, o_id, src, clientId );
}

async [OrderLineTable<colId>] OrderStatusTransactionOrderLine( const uint32_t& colId, const int32_t& o_id, const MaceKey& src, 
    const uint32_t& clientId){
  ADD_SELECTORS("TreeTPCCAppServer");
  
  mace::vector<OrderStatusOrderLine> order_lines;

  for( uint32_t i=0; i<tableEntries.size(); i++ ) {
    OrderLineTableEntry& entry = tableEntries[i];

    OrderStatusOrderLine line;
    if( o_id == entry.ol_o_id ) {
      line.ol_i_id = entry.ol_i_id;
      line.ol_supply_w_id = entry.ol_supply_w_id;
      line.ol_quantity = entry.ol_quantity;
      line.ol_amount = entry.ol_amount;
      line.ol_delivery_d = entry.ol_delivery_d;
      order_lines.push_back(line);
    }
  }

  if( clientId >0 ){
    downcall_route(src, RequestReply(clientId, false, 0, 0, 0) );
  }
}

// The Delivery Transaction
upcall [DistrictTable<msg.d_id>] deliver(const MaceKey& src, const MaceKey& dest, const DeliveryTransactionMessage& msg ) {
  ADD_SELECTORS("TreeTPCCAppServer");

  int32_t o_carrier_id = msg.o_carrier_id;
  mace::string ol_delivery_d = "datetime";
  uint32_t clientId = msg.client_id;

  const DistrictTableEntry& entry = tableEntries[0];
  if( entry.d_next_o_id == 1 ){
    if( clientId >0 ){
      downcall_route(src, RequestReply(clientId, false, 0, 0, 0) );
    }
    return;
  }

  int32_t no_o_id = oldestNewOrderId ++;
  uint32_t c_id = orderCustomerMap[no_o_id];

  uint32_t ct_iter = c_id % N_CUSTOMER_TABLE_PER_DISTRICT;
  uint32_t ct_id = customerTables[ct_iter];

  async_DeliveryTransactionCustomer( ct_id, no_o_id, o_carrier_id, ol_delivery_d, src, clientId );
}

async [CustomerTable<ccId>] DeliveryTransactionCustomer( const uint32_t& ccId, const int32_t& o_id, const int32_t& o_carrier_id, 
    const mace::string& ol_delivery_d, const MaceKey& src, const uint32_t& clientId) {
  ADD_SELECTORS("TreeTPCCAppServer");
  
  DeliveryOrder delivery_order = DeliveryTransactionOrder( ccId, o_id, o_carrier_id, ol_delivery_d );
  if( delivery_order.ol_total > 0 ){
    for( uint32_t i=0; i<tableEntries.size(); i++ ) {
      CustomerTableEntry& entry = tableEntries[i];

      if( delivery_order.o_c_id == entry.c_id ) {
        entry.c_balance = entry.c_balance + delivery_order.ol_total;
        break;
      }
    }
  } 
  
  downcall_route( src, RequestReply(clientId, false, 0, 0, 0) );
}

// The Stock-Level Transaction
upcall [WarehouseTable<msg.w_id>] deliver(const MaceKey& src, const MaceKey& dest, const StockLevelTransactionMessage& msg) {
  ADD_SELECTORS("TreeTPCCAppServer");
  reqCount ++;
  stockLevelReqCount ++;
  if( reqCount % OUTPUT_COUNT == 0 ){
    maceout << "In WarehouseTable[] reqCount="<< reqCount << " newOrderReqCount=" << newOrderReqCount << " paymentReqCount=" 
            << paymentReqCount << " orderStatusReqCount=" << orderStatusReqCount << " deliveryReqCount=" << deliveryReqCount 
            << " stockLevelReqCount=" << stockLevelReqCount << Log::endl;
  }
  
  uint32_t dt_iter = msg.d_id % N_DISTRICT_PER_WAREHOUSE;
  uint32_t dt_id = districtTables[dt_iter];

  uint32_t stock_count = 0;
  mace::set<int32_t> i_ids = StockLevelTransactionDistrict( dt_id, msg.d_id );

  mace::map< uint32_t, mace::set<int32_t> > ctxMap;
  for( mace::set<int32_t>::iterator i_iter=i_ids.begin(); i_iter!=i_ids.end(); i_iter++ ) {
    int32_t i_id = *i_iter;
    uint32_t ist_iter = i_id % N_ITEMSTOCK_TABLE_PER_WAREHOUSE;
    uint32_t ist_id = itemStockTables[ist_iter];
    ctxMap[ ist_id ].insert( i_id );    
  }

  for( mace::map< uint32_t, mace::set<int32_t> >::iterator iter=ctxMap.begin(); iter!=ctxMap.end(); iter++ ){
    stock_count += StockLevelTransactionStock( iter->first, iter->second, msg.threshold );
  }
  downcall_route( src, RequestReply(msg.client_id, false, 0, 0, 0) );
}

upcall deliver(const MaceKey& src, const MaceKey& dest, const ConnectionRequest& msg ) {
  ADD_SELECTORS("TreeTPCCAppServer");
  std::ostringstream oss;
  oss << src <<"["<<msg.clientId<<"]";

  MaceAddr commAddr = getExternalCommContextAddr(src, oss.str() );
  MaceKey commKey( ipv4, commAddr );
  downcall_route( src, ConnectionSetup(commKey, msg.clientId) );
  maceout<< "Assign external communication node("<< commKey <<") to client[] from "<< src <<"!" << Log::endl;
}

} // transition

routines {

// Delivery transaction
[OrderTable<coId>] DeliveryOrder DeliveryTransactionOrder( const uint32_t& coId, const int& o_id, const int32_t& o_carrier_id, const mace::string& ol_delivery_d) {
  
  ADD_SELECTORS("TreeTPCCAppServer");
  
  DeliveryOrder delivery_order;
  delivery_order.ol_total = 0;
  for( uint32_t i=0; i<tableEntries.size(); i++ ) {
    OrderTableEntry& entry = tableEntries[i];

    if( o_id == entry.o_id ) {
      delivery_order.o_c_id = entry.o_c_id;
      delivery_order.ol_total = DeliveryTransactionOrderLine(coId, o_id, ol_delivery_d);
      
      entry.o_carrier_id = o_carrier_id;
      break;
    }
  }
  return delivery_order;
}

[OrderLineTable<colId>] uint32_t DeliveryTransactionOrderLine( const uint32_t& colId, const int& o_id, const mace::string& ol_delivery_d ) {
  ADD_SELECTORS("TreeTPCCAppServer");

  uint32_t ol_total = 0;
  for( uint32_t i=0; i<tableEntries.size(); i++ ) {
    OrderLineTableEntry& entry = tableEntries[i];
    if( o_id == entry.ol_o_id ) {
      entry.ol_delivery_d = 100;
      ol_total ++;      
    }
  } 
  return ol_total;
}


// Stock-Level Transaction
[DistrictTable<cdId>] mace::set<int32_t> StockLevelTransactionDistrict( const uint32_t& cdId, const int32_t& d_id ) {
  ADD_SELECTORS("TreeTPCCAppServer");

  int32_t d_next_o_id = 0;

  for( uint32_t i=0; i<tableEntries.size(); i++ ) {
    if( tableEntries[i].d_id == d_id ){
      d_next_o_id = tableEntries[i].d_next_o_id;
      break;
    }
  }

  int32_t max = d_next_o_id;
  int32_t min = d_next_o_id - 20;
  if( min<0 ){
    min = 0;
  }
  mace::set<RangeOrderInfo> o_ids;

  for( mace::map<uint32_t, uint32_t>::iterator iter = orderCustomerMap.begin(); iter != orderCustomerMap.end(); iter ++ ) {
    if( iter->first >= (uint32_t)min && iter->second < (uint32_t)max ) {
      RangeOrderInfo info(iter->first, iter->second);
      o_ids.insert(info);
    }
  }
  
  mace::set<int32_t> i_ids;
  for( mace::set<RangeOrderInfo>::iterator iter=o_ids.begin(); iter!=o_ids.end(); iter++ ) {
    const RangeOrderInfo& order_info = *iter;
    uint32_t c_table = order_info.c_id % N_CUSTOMER_TABLE_PER_DISTRICT;

    mace::set<int32_t> item_ids = StockLevelTransactionCustomer( c_table, order_info.c_id, order_info.o_id);

    for( mace::set<int32_t>::iterator i_iter=item_ids.begin(); i_iter!=item_ids.end(); i_iter++ ){
      const int32_t& item_id = *i_iter;
      if( i_ids.count(item_id) == 0 ){
        i_ids.insert(item_id);
      }
    }
  }

  return i_ids;
}

[CustomerTable<ccId>] mace::set<int32_t> StockLevelTransactionCustomer( const uint32_t& ccId, const int32_t& c_id, const int32_t& o_id ){
  return StockLevelTransactionOrder( ccId, c_id, o_id );
}

[OrderTable<coId>] mace::set<int32_t> StockLevelTransactionOrder(const uint32_t& coId, const int32_t& c_id, const int32_t& o_id) {
  ADD_SELECTORS("TreeTPCCAppServer");
  return StockLevelTransactionOrderLine(coId, o_id);
}

[OrderLineTable<colId>] mace::set<int32_t> StockLevelTransactionOrderLine( const uint32_t& colId, const int32_t& o_id){
  ADD_SELECTORS("TreeTPCCAppServer");

  
  mace::set<int32_t> i_ids;

  for(uint32_t i=0; i<tableEntries.size(); i++){
    const OrderLineTableEntry& entry = tableEntries[i];
    if( entry.ol_o_id == o_id ) {
      if( i_ids.count(entry.ol_i_id) == 0 ){
        i_ids.insert(entry.ol_i_id);
      }
    }
  }
  return i_ids;
}


[ItemStockTable<csId>] uint32_t StockLevelTransactionStock( const uint32_t& csId, const mace::set<int32_t>& i_ids, const uint32_t& threshold) {
  ADD_SELECTORS("TreeTPCCAppServer");

  uint32_t count = 0;
  for( mace::set<int32_t>::iterator iter=i_ids.begin(); iter!=i_ids.end(); iter++ ) {
    const int32_t& i_id = *iter; 
    uint32_t i_iter = i_id % tableEntries.size();
    ItemStockTableEntry& entry = tableEntries[i_iter];
    
    if( entry.s_quantity < (int)threshold ) {
      count ++;
    } 
  }

  return count;
}


[__null] uint32_t getContextID( const int32_t& entryId, const uint32_t& N_ENTRY_PER_CONTEXT, mace::map<uint32_t, uint32_t>& contextIdMap ){
  uint32_t iter = entryId / N_ENTRY_PER_CONTEXT;
  if( contextIdMap.find(iter) == contextIdMap.end() ) {
    return 0;
  } else {
    uint32_t ctxId = contextIdMap[iter];
    return ctxId;
  }
}

[__null] void updateContextID( const int32_t& entryId, const uint32_t& ctxId, const uint32_t& N_ENTRY_PER_CONTEXT, mace::map<uint32_t, uint32_t>& contextIdMap ){

  uint32_t iter = entryId / N_ENTRY_PER_CONTEXT;
  contextIdMap[iter] = ctxId;
}

[__null] uint32_t getCustomerContextIDByName( const mace::string& c_last, 
    const mace::map< mace::string, mace::set<C_Last_Index_Entry> >& c_last_idx) {

  mace::map< mace::string, mace::set<C_Last_Index_Entry> >::const_iterator iter = c_last_idx.find( c_last );
  if( iter == c_last_idx.end() ){
    return 0;
  }

  const mace::set<C_Last_Index_Entry>& c_entries = iter->second;
  if( c_entries.size() == 0 ) {
    return 0;
  }

  uint32_t mid = c_entries.size() / 2;
  mace::set<C_Last_Index_Entry>::const_iterator entry_iter;
  int32_t c_id = 0;
  uint32_t i = 0;
  for( entry_iter=c_entries.begin(); entry_iter!=c_entries.end(); entry_iter++, i++ ) {
    if( i== mid ){
      c_id = (*entry_iter).c_id;
      break;
    }
  }
  return c_id;
}

[__null] mace::string generateContextName( const mace::string& ctxName, const uint32_t& id) {
  std::ostringstream oss;
  oss << ctxName <<"["<<id<<"]";
  return oss.str();
}

[__null] int32_t NURand(const int32_t& A, const int32_t& x, const int32_t& y) {
  int32_t C = RandomUtil::randInt(A+1);

  int32_t r = ((( RandomUtil::randInt(A) | (RandomUtil::randInt(y-x) + x) ) + C) % (y-x+1)) + x;
  return r;
} 

[__null] mace::string Lastname( const int& num ){
    mace::vector<mace::string> n;
    n.push_back("BAR");
    n.push_back("OUGHT");
    n.push_back("ABLE");
    n.push_back("PRI");
    n.push_back("ESE");
    n.push_back("ANTI");
    n.push_back("CALLY");
    n.push_back("ATION");
    n.push_back("EING");


    mace::string name = n[ (num/100) %9];
    name += n[(num/10)%9];
    name += n[num % 9];
    return name;
  }

[__null] mace::string generateRandomString(const uint32_t& l) {
  uint32_t len = l;
  if( len == 0 ) {
    len = RandomUtil::randInt(30) + 1;
  }

  std::string buf(len-1, 0);
  uint32_t i = 0;
  char seed = 'a';
  while( i<len-1 ) {
    const char c =  (char)( (uint32_t)seed + RandomUtil::randInt(26) );
    buf[i++] = c;
  }

  return buf;
}

}

