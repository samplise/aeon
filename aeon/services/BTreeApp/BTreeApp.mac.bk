
#include <stdlib.h>

service BTreeApp;
provides Null;

typedefs {
}
services {

}

constants {
  uint8_t READ_OP = 0;
  uint8_t INSERT_OP = 1;
  uint8_t DELETE_OP = 2;
  uint8_t SCAN_OP = 3;

  uint8_t REMOVE_OWNERSHIP = 1;
  uint8_t CREATE_OWNERSHIP = 2;
}

constructor_parameters {
  uint32_t MAX_NKEY_PER_NODE = 10;
  uint32_t MIN_NKEY_PER_NODE = 5;
  uint64_t OUTPUT_COUNT = 10;
  uint32_t CACHED_KEY = 0; 
}

messages {

}

auto_types {
  KeyInfo {
    int key;
    int value;
    uint32_t l_node;
    uint32_t r_node;
  }

  OpInfo {
    int key;
    int value;
    uint8_t opType;
  }
}
 
state_variables {
  context Client<uint32_t clindId> {
    uint32_t clientId;

    uint64_t totalReqCount;
    uint64_t readReqCount;
    uint64_t insertReqCount;
    uint64_t deleteReqCount;
    uint64_t scanReqCount;

    mace::vector<OpInfo> workloadOps;

    uint64_t lastReqLauchedTime;
    uint8_t lastReqType;

    uint64_t totalReqLatency;
    uint64_t readReqLatency;
    uint64_t insertReqLatency;
    uint64_t deleteReqLatency;
    uint64_t scanReqLatency;
    
    mace::map<int, uint32_t> nodeCache;

    OpInfo lastOp;
  }

  context BTree {
    uint32_t rootNodeId;
  }

  context BTreeNode<uint32_t nodeId> {
    mace::vector<KeyInfo> keyInfos;
    
    uint32_t parentId;
    uint32_t myNodeId;
    bool root_flag;
    bool leaf_flag;
  }

}


 
transitions {
  downcall maceInit()  {
    ADD_SELECTORS("BTreeApp");
    mace::vector<OpInfo> ops;
        
    /*
    FILE *fr = fopen(WORKLOAD_FILE.c_str(), "r");
    if( fr == NULL ) {
      maceout << "Fail to open file " << WORKLOAD_FILE << Log::endl;
      return;
    }
    char line[80];
    while( fgets(line, 80, fr) != NULL ) {
      std::vector<std::string> v;
      std::string lineStr = line;
      split(lineStr, ',', v);
      if( v.size() != 3 ) {
        continue;
      }

      OpInfo opInfo;
      int key = atoi(v[1].c_str());
      int frequency = atoi(v[2].c_str());
      if( frequency == 0 ) {
        continue;
      } 

      if( v[0] == "[UPDATE]") {
        opInfo.opType = UPDATE_OP;
        opInfo.key = key;
        opInfo.value = 100;

        opCount = opCount + frequency;
        opInfo.frequency = opCount;
        ops.push_back(opInfo);
      } else if( v[0] == "[READ]") {
        opInfo.opType = READ_OP;
        opInfo.key = key;
        opInfo.value = 100;

        opCount = opCount + frequency;
        opInfo.frequency = opCount;
        ops.push_back(opInfo);
      }
    }
    fclose(fr);

    maceout << "ops=" << ops << ", opCount=" << opCount << Log::endl;
    */

    for(uint32_t i=0; i<NCLIENT; i++) {
      uint32_t clientId = createNewContext("Client");
      mace::string clientCtxName = generateContextName("Client", clientId);
      createNewOwnership("globalContext", clientCtxName);
      async_initClient(clientId, ops);
    }
    async_initBTree();
  }

  async [Client<cId>] initClient(const uint32_t& cId, mace::vector<OpInfo> const& ops ) {
    ADD_SELECTORS("BTreeApp");
    maceout<< "To initialize Client " << cId << Log::endl;
    clientId = cId;
    
    workloadOps = ops;

    totalReqCount = 0;
    readReqCount = 0;
    insertReqCount = 0;
    deleteReqCount = 0;
    scanReqCount = 0;

    totalReqLatency = 0;
    readReqLatency = 0;
    insertReqLatency = 0;
    deleteReqLatency = 0;
    scanReqLatency = 0;

  }

  async [Client<cId>] launchRequest( const uint32_t& cId ) {
    ADD_SELECTORS("BTree");
    uint64_t nextValue = 100;

    uint64_t nextKey =  ( rand()+cId ) % MAX_KEY;
    uint64_t pc = ( rand()+nextKey ) % 100;

    uint8_t opType = READ_OP;

    if( pc < READ_OP ){
      opType = READ_OP;
    } else if ( pc < INSERT_OP ) {
      opType = INSERT_OP;
    } else if ( pc < DELETE_OP ) {
      opType = DELETE_OP;
    } else {
      opType = SCAN_OP;
      nextValue = rand() % (MAX_KEY-nextKey) + nextKey;
    }
    
    lastOp.key = nextKey;
    lastOp.value = nextValue;
    lastOp.opType = opType;
    
    lastRequestLauchedTime = mace::getmtime();

    if( lastOp.opType == SCAN_OP ){
      async_scanKeyInBTree(clientId, lastOp.key, lastOp.value );
      return;
    }

    if( nodeCache.find(lastOp.key) == nodeCache.end() ) {
      if( lastOp.opType == READ_OP) {
        async_searchKeyInBTree(clientId, lastOp.key );
      } else if( lastOp.opType == INSERT_OP ){
        async_insertKeyToBTree(clientId, lastOp.key, lastOp.value );
      } else if( lastOp.opType == DELETE_OP ) {
        async_deleteKeyFromBTree( clientId, lastOp.key );
      }
    } else {
      if( lastOp.opType == READ_OP ) {
        async_searchKeyDirect( nodeCache[lastOp.key], cId, lastOp.key );
      } else if( lastOp.opType == INSERT_OP ){
        async_insertKeyDirect( nodeCache[lastOp.key], cId, lastOp.key, lastOp.value );
      } else if( lastOp.opType == DELETE_OP ) {
        async_deleteKeyDirect( clientId, lastOp.key );
      }
    }
  }

  async [Client<cId>] requestReply(const uint32_t& cId, const mace::vector< mace::pair<int, int> >& values, const uint32_t& nodeId, const bool& succ) {

    ADD_SELECTORS("BTreeApp");

    if( CACHED_KEY > 0 ) {
      if( succ && lastOp.opType != SCAN_OP && lastOp.opType != DELETE_OP ) {
          nodeCache[lastOp.key] = nodeId;
      } 
    }

    uint64_t lastReqLatency = mace::getmtime() - lastReqLauchedTime;
    totalReqCount ++;
    totalReqLatency += lastReqLatency;

    if( lastOp.opType == READ_OP ) {
      readReqCount ++;
      readReqLatency += lastReqLatency;
    } else if( lastOp.opType == INSERT_OP ) {
      insertReqCount ++;
      insertReqLatency += lastReqLatency;
    } else if( lastOp.opType == SCAN_OP ) {
      scanReqCount ++;
      scanReqLatency += lastReqLatency;
    } else if( lastOp.opType == DELETE_OP ) {
      deleteReqCount ++;
      deleteReqLatency += lastReqLatency;
    }

    if( totalReqCount % OUTPUT_COUNT == 0 ) {
      double avgReqLatency = totalReqLatency / OUTPUT_COUNT;
      maceout << "Client("<< cId <<") totalReqCount=" << totalReqCount << " avgReqLatency=" << avgReqLatency <<"; readReqCount=" << readReqCount << " avgReadReqLatency="<< readReqLatnecy/readReqCount <<"; insertReqCount=" << insertReqCount << " avginsertReqLatency="<< insertReqLatnecy/insertReqCount <<"; scanReqCount=" << scanReqCount << " avgScanReqLatency="<< scanReqLatnecy/scanReqCount <<"; deleteReqCount=" << deleteReqCount << " avgDeleteReqLatency="<< deleteReqLatnecy/deleteReqCount <<  Log::endl;
      
      totalReqLatency = 0;

      readReqCount = 0;
      readReqLatency = 0;

      insertReqCount = 0;
      insertReqLatency = 0;

      insertReqCount = 0;
      insertReqLatency = 0;

      deleteReqCount = 0;
      deleteReqLatency = 0;
    }


    uint64_t nextValue = 0;

    uint64_t nextKey =  ( rand()+cId ) % MAX_KEY;
    uint64_t pc = ( rand()+nextKey ) % 100;

    uint8_t opType = READ_OP;

    if( pc < READ_OP ){
      opType = READ_OP;
    } else if ( pc < INSERT_OP ) {
      opType = INSERT_OP;
    } else {
      opType = SCAN_OP;
      nextValue = rand() % (MAX_KEY-nextKey) + nextKey;
    }
    
    lastOp.key = nextKey;
    lastOp.value = nextValue;
    lastOp.opType = opType;
    
    lastRequestLauchedTime = mace::getmtime();

    if( lastOp.opType == SCAN_OP ){
      async_scanKeyInBTree(clientId, lastOp.key, lastOp.value );
      return;
    }

    if( nodeCache.find(lastOp.key) == nodeCache.end() ) {
      if( lastOp.opType == READ_OP) {
        async_searchKeyInBTree(clientId, lastOp.key );
      } else if( lastOp.opType == INSERT_OP ){
        async_insertKeyToBTree(clientId, lastOp.key, lastOp.value );
      } else if( lastOp.opType == DELETE_OP ) {
        async_deleteKeyFromBTree( clientId, lastOp.key );
      }
    } else {
      if( lastOp.opType == READ_OP ) {
        async_searchKeyDirect( nodeCache[lastOp.key], cId, lastOp.key );
      } else if( lastOp.opType == INSERT_OP ){
        async_insertKeyDirect( nodeCache[lastOp.key], cId, lastOp.key, lastOp.value );
      } else if( lastOp.opType == DELETE_OP ) {
        async_deleteKeyDirect( clientId, lastOp.key );
      }
    }
  }

  async [BTree] initBTree() {
    ADD_SELECTORS("BTreeApp");
    maceout<< "Initialize BTree!" << Log::endl;
    uint32_t nodeId = createNewContext("BTreeNode");
    rootNodeId = nodeId;
    mace::string contextName = generateContextName("BTreeNode", nodeId);
    createNewOwnership("BTree", contextName);
    broadcast_initializeBTreeNode(nodeId, 0, true, true);
    
    sleep(1);
    maceout << "Start " << NCLIENT << " clients for testing!" << Log::endl;
    for(uint32_t i=1; i <= NCLIENT; i++) {
      async_launchRequest(i);
    }
  }

  async [BTree] searchKeyInBTree(const uint32_t& cId, const int& key) [locking = read] {
    ADD_SELECTORS("BTreeApp");
    if( rootNodeId <= 0){
      maceout <<"ERROR: rootNodeId=" << rootNodeId << Log::endl; 
      return;
    }
    broadcast_searchKeyInBTreeNode(rootNodeId, cId, key);
  }

  async [BTree] insertKeyToBTree( const uint32_t& cId, const int& key, const int& value ) {
    broadcast_insertKeyToBTreeNode(rootNodeId, cId, key, value);
  }

  async [BTree] scanKeyInBTree( const uint32_t& cId, const int& min_key, const int& max_key ) [locking = read] {
    broadcast_scanKeyInBTreeNode(rootNodeId, cId, min_key, max_key);
  }

  async [BTree] deleteKeyFromBTree( const uint32_t& cId, const int& key ) {
    broadcast_deleteKeyFromBTreeNode(rootNodeId, cId, key);
  }

  async [BTreeNode<nodeId>] adjust(const uint32_t& nodeId, const uint32_t& childId) {
    ADD_SELECTORS("BTreeApp");
    maceout << "Adjust BTreeNode("<< nodeId <<")->BTreeNode("<< childId <<")"<< Log::endl; 
    if( nodeId == childId ){
      // it's the root
      if( keyInfos.size() > MAX_NKEY_PER_NODE) {
        maceout << "To split root BTreeNode("<< myNodeId <<")" << Log::endl;
        uint32_t mid = (uint32_t)( keyInfos.size() / 2);
        mace::vector<KeyInfo> l_node_keys;
        mace::vector<KeyInfo> r_node_keys;

        mace::vector<uint32_t> toRemoveNodeIds;
      
        mace::string my_contextName = generateContextName("BTreeNode", myNodeId);
        for(uint32_t i=0; i<keyInfos.size(); i++) {
          uint32_t nodeId = keyInfos[i].l_node;
          if( nodeId > 0 ) {
            toRemoveNodeIds.push_back(nodeId);
          }

          if( i+1 == keyInfos.size() ) {
            nodeId = keyInfos[i].r_node;
            if( nodeId > 0 ) {
              toRemoveNodeIds.push_back(nodeId);
            }
          }

          if( i<mid ){
            l_node_keys.push_back(keyInfos[i]);
          } else if( i==mid ){
            KeyInfo& tmp_key = l_node_keys[ l_node_keys.size()-1 ];
            tmp_key.r_node = keyInfos[i].l_node;
          } else if( i>mid ){
            r_node_keys.push_back(keyInfos[i]);
          }
        }

        KeyInfo new_key = keyInfos[mid];

        keyInfos.clear();

        for( uint32_t i=0; i<toRemoveNodeIds.size(); i++ ){
          changePCRelation(myNodeId, toRemoveNodeIds[i], REMOVE_OWNERSHIP);
        }
        
        uint32_t l_node_id = createNewContext("BTreeNode");
        uint32_t r_node_id = createNewContext("BTreeNode");

        
        
        mace::string l_contextName = generateContextName("BTreeNode", l_node_id);
        mace::string r_contextName = generateContextName("BTreeNode", r_node_id);
        createNewOwnership(my_contextName, l_contextName);
        createNewOwnership(my_contextName, r_contextName);

        initializeBTreeNode2(l_node_id, myNodeId, false, l_node_keys);
        initializeBTreeNode2(r_node_id, myNodeId, false, r_node_keys);

        new_key.l_node = l_node_id;
        new_key.r_node = r_node_id;
        keyInfos.push_back(new_key);
        leaf_flag = false;
        
      } else if( keyInfos.size() < MIN_NKEY_PER_NODE ) {
        //maceout << "Something wrong!" << Log::endl;
      }
    } else {
      if( !checkParentChild(keyInfos, childId) ) {
        maceout << "Now BTreeNode("<< myNodeId <<") is not the parent of BTreeNode("<< childId <<")!" << Log::endl;
        return;
      }
      if( getKeySize(childId) > MAX_NKEY_PER_NODE ) {
        //maceout<< "Modify BTreeNode("<< childId<<")" << Log::endl;
        uint32_t l_sibling_id = 0;
        uint32_t r_sibling_id = 0;

        int l_pos = -1;
        int r_pos = -1;
        int child_pos = -1;
        
        for(uint32_t i=0; i<keyInfos.size(); i++) {
          uint32_t cur_node_id = keyInfos[i].l_node;
          if( keyInfos[i].l_node == childId ){
            child_pos = i;
            if( i == keyInfos.size()-1 ) {
              r_sibling_id = keyInfos[i].r_node;
              r_pos = i;
            } else {
              r_sibling_id = keyInfos[i+1].l_node;
              r_pos = i+1;
            }
            break;
          } else if( i==keyInfos.size()-1 && keyInfos[i].r_node == childId ) {
            child_pos = i;
            l_pos = i;
            l_sibling = keyInfos[i].l_node;
            break;
          }

          l_sibling = keyInfos[i].l_node;
          l_pos = i;
        }
        
        if( l_sibling_id > 0 && getKeySize(l_sibling_id) < MAX_NKEY_PER_NODE ) {
          //maceout << "Before movement BTreeNode("<< myNodeId<<") keyInfos="<< keyInfos << Log::endl;
          KeyInfo new_key = removeMostLeftKey(childId);
          int tmp = keyInfos[l_pos].key; 
          keyInfos[l_pos].key = new_key.key;
          new_key.key = tmp;
          new_key.r_node = new_key.l_node;
          new_key.l_node = 0;
          addMostRightKey(l_sibling_id, new_key);
          /*
            maceout << "Move one key from BTreeNode("<< childId <<") to left sibling BTreeNode("<<l_sibling_id<<"). BTreeNode("<< myNodeId <<")   keyInfos="<< keyInfos << Log::endl;
          */
          return; 
        }
        
        if( r_sibling_id > 0 &&  getKeySize(r_sibling_id) < MAX_NKEY_PER_NODE ) {
          //maceout << "Before movement BTreeNode("<< myNodeId<<") keyInfos="<< keyInfos << Log::endl;
          KeyInfo new_key = removeMostRightKey(childId);
          int tmp = keyInfos[child_pos].key; 
          keyInfos[child_pos].key = new_key.key;
          new_key.key = tmp;
          new_key.l_node = new_key.r_node;
          new_key.r_node = 0;
          addMostLeftKey(r_sibling_id, new_key);
          /*
            maceout << "Move one key from BTreeNode("<< childId <<") to right sibling BTreeNode("<<r_sibling_id<<"). BTreeNode("<< myNodeId <<")   keyInfos="<< keyInfos << Log::endl;
          */
          return;
        }

        // maceout << "Before split BTreeNode("<< childId <<"), BTreeNode("<< myNodeId<<") keyInfos="<< keyInfos << Log::endl;

        mace::vector<KeyInfo> new_l_keys = splitLeftKeys(childId);
        mace::vector toRemoveChildIds = getValidChildIDs(new_l_keys);
        

        KeyInfo new_key = new_l_keys.back();
        new_l_keys.pop_back();
        new_l_keys[ new_l_keys.size()-1 ].r_node = new_key.l_node;
        new_key.l_node = 0;

        uint32_t new_l_id = createNewContext("BTreeNode");
        mace::string my_contextName = generateContextName("BTreeNode", myNodeId);
        mace::string l_contextName = generateContextName("BTreeNode", new_l_id);
        createNewOwnership( my_contextName, l_contextName);
        initializeBTreeNode2(new_l_id, myNodeId, false, new_l_keys);

        new_key.l_node = new_l_id;
        removeChildrenInChildNode( childId, toRemoveChildIds);

        for( mace::vector<KeyInfo>::iterator iter=keyInfos.begin(); iter!=keyInfos.end(); iter++ ) {
          KeyInfo& keyInfo = *iter;
          if( keyInfo.l_node == childId ) {
            keyInfos.insert( iter, new_key );
            break;
          }

          if( iter+1 == keyInfos.end() && keyInfo.r_node == childId ){
            keyInfo.r_node = 0;
            new_key.r_node = childId;
            new_key.l_node = new_l_id;
          }
        }

        if( keyInfos.size() > MAX_NKEY_PER_NODE ) {
          //maceout << "To further adjust BTreeNode("<< myNodeId<<") key_size=" << keyInfos.size() << Log::endl;
          if( parentId == 0){
            async_adjust(myNodeId, myNodeId);
          } else {
            async_adjust(parentId, myNodeId);
          }
        }
        //maceout << "After split BTreeNode("<< childId <<"), BTreeNode("<< myNodeId<<") keyInfos="<< keyInfos << Log::endl;
      } else if( getKeySize(childId) < MIN_NKEY_PER_NODE ){
        //maceout << "Start to adjust BTreeNode("<< childId <<")!" << Log::endl;
        uint32_t l_sibling_id = 0;
        uint32_t r_sibling_id = 0;

        int l_pos = -1;
        int r_pos = -1;
        int child_pos = -1;
        
        for(uint32_t i=0; i<keyInfos.size(); i++) {
          uint32_t cur_node_id = keyInfos[i].l_node;
          if( keyInfos[i].l_node == childId ){
            child_pos = i;
            if( i == keyInfos.size()-1 ) {
              r_sibling_id = keyInfos[i].r_node;
              r_pos = i;
            } else {
              r_sibling_id = keyInfos[i+1].l_node;
              r_pos = i+1;
            }
            break;
          } else if( i==keyInfos.size()-1 && keyInfos[i].r_node == childId ) {
            child_pos = i;
            l_pos = i;
            l_sibling = keyInfos[i].l_node;
            break;
          }

          l_sibling = keyInfos[i].l_node;
          l_pos = i;
        }

        //maceout << "Adjust: l_sibling_id=" << l_sibling_id << ", r_sibling_id=" << r_sibling_id << Log::endl;
        // move one key from left sibling node
        if( l_sibling_id > 0 && getKeySize(l_sibling_id) > MIN_NKEY_PER_NODE ) {
          //maceout << "Before movement BTreeNode("<< myNodeId<<") keyInfos="<< keyInfos << Log::endl;
          KeyInfo new_key = removeMostRightKey(l_sibling_id);
          int tmp = keyInfos[l_pos].key; 
          keyInfos[l_pos].key = new_key.key;
          new_key.key = tmp;
          new_key.l_node = new_key.r_node;
          new_key.r_node = 0;
          addMostLeftKey(childId, new_key);
          /*
          maceout << "Move one key from BTreeNode("<< l_sibling_id <<") to right sibling BTreeNode("<<childId<<"). BTreeNode("<< myNodeId <<")   keyInfos="<< keyInfos << Log::endl;
          */
          return; 
        }
        
        // move one key from right sibling node
        if( r_sibling_id > 0 && getKeySize(r_sibling_id) > MIN_NKEY_PER_NODE ) {
          //maceout << "Before movement BTreeNode("<< myNodeId<<") keyInfos="<< keyInfos << Log::endl;
          KeyInfo new_key = removeMostLeftKey(r_sibling_id);
          int tmp = keyInfos[child_pos].key; 
          keyInfos[child_pos].key = new_key.key;
          new_key.key = tmp;
          new_key.r_node = new_key.l_node;
          new_key.l_node = 0;
          addMostRightKey(childId, new_key);
          /* 
            maceout << "Move one key from BTreeNode("<< r_sibling_id <<") to left sibling BTreeNode("<<childId<<"). BTreeNode("<< myNodeId <<")   keyInfos="<< keyInfos << Log::endl;
          */
          return;
        }
  
        //maceout << "Before concatenate BTreeNode("<< myNodeId <<"). keyInfos="<< keyInfos << Log::endl;
        if( keyInfos.size() == 1 ) {
          uint32_t l_node_id = keyInfos[0].l_node;
          uint32_t r_node_id = keyInfos[0].r_node;
          
          keyInfos[0].l_node = 0;
          keyInfos[0].r_node = 0;          

          mace::vector<KeyInfo> l_keyInfos;
          mace::vector<KeyInfo> r_keyInfos;

          if( l_node_id > 0 ){
            l_keyInfos = getKeys( l_node_id );
          }
          if( r_node_id > 0 ){
            r_keyInfos = getKeys( r_node_id );
          }

          mace::vector<KeyInfo> new_key_infos;
          mace::vector<uint32_t> toAddChildIds;

          for( uint32_t i=0; i<l_keyInfos.size(); i++ ) {
            if( l_keyInfos[i].l_node > 0 ){
              toAddChildIds.push_back(l_keyInfos[i].l_node);
            }
            if( i==l_keyInfos.size()-1 ) {
              if( l_keyInfos[i].r_node > 0 ) {
                toAddChildIds.push_back(l_keyInfos[i].r_node); 
              }
              keyInfos[0].l_node = l_keyInfos[i].r_node;
              l_keyInfos[i].r_node = 0;
            }
            new_key_infos.push_back(l_keyInfos[i]);
          }
          new_key_infos.push_back(keyInfos[0]);
          for( uint32_t i=0; i<r_keyInfos.size(); i++ ) {
            if( r_keyInfos[i].l_node > 0 ){
              toAddChildIds.push_back(r_keyInfos[i].l_node);
            }
            if( i==r_keyInfos.size()-1 && r_keyInfos[i].r_node > 0 ) {
              toAddChildIds.push_back(r_keyInfos[i].r_node); 
            }
            new_key_infos.push_back(r_keyInfos[i]);
          }

          addChildNodes(myNodeId, toAddChildIds);
          if( l_node_id>0 ){
            removeAllChildren(l_node_id);
          }
          if( r_node_id>0 ) {
            removeAllChildren(r_node_id);
          }
          if( l_node_id>0 ){
            changePCRelation(myNodeId, l_node_id, REMOVE_OWNERSHIP);
          }
          if( r_node_id>0 ) {
            changePCRelation(myNodeId, r_node_id, REMOVE_OWNERSHIP);
          }

          KeyInfos = new_key_infos;
          return;
        } else {
          uint32_t l_node_id = 0;
          uint32_t r_node_id = 0;

          KeyInfo pKeyInfo;

          if( l_sibling_id > 0 ){
            l_node_id = l_sibling_id;
            r_node_id = childId;
            pKeyInfo = keyInfos[l_pos];
          } else if( r_sibling_id > 0 ){
            l_node_id = childId;
            r_node_id = r_sibling_id;
            pKeyInfo = keyInfos[child_pos];
          } else { // no left & right sibling
            if( keyInfos[child_pos].r_node == childId ) {
              r_node_id = childId;
            } else {
              l_node_id = childId;
            }
            pKeyInfo = keyInfos[child_pos];
          }

          ASSERT( l_node_id>0 || r_node_id>0 );
          pKeyInfo.l_node = 0;
          pKeyInfo.r_node = 0;

          mace::vector<KeyInfo> l_keyInfos;
          mace::vector<KeyInfo> r_keyInfos;

          if( l_node_id > 0 ){
            l_keyInfos = getKeys( l_node_id );
          }
          if( r_node_id > 0 ){
            r_keyInfos = getKeys( r_node_id );
          }

          mace::vector<KeyInfo> new_key_infos;
          
          for( uint32_t i=0; i<l_keyInfos.size(); i++ ) {
            if( i==l_keyInfos.size()-1 ) {
              pKeyInfo.l_node = l_keyInfos[i].r_node;
              l_keyInfos[i].r_node = 0;
            }
            new_key_infos.push_back(l_keyInfos[i]);
          }
          new_key_infos.push_back(pKeyInfo);
          for( uint32_t i=0; i<r_keyInfos.size(); i++ ) {
            new_key_infos.push_back(r_keyInfos[i]);
          }

          for( mace::vector<KeyInfo>::iterator iter=keyInfos.begin(); iter!=keyInfos.end(); iter++ ) {
            if( (*iter).key == pKeyInfo.key ) {
              if( iter+1 == keyInfos.end() ) {
                if( r_node_id > 0 ) {
                  *(iter-1).r_node = r_node_id; 
                } else {
                  ASSERT( l_node_id > 0);
                  *(iter-1).r_node = l_node_id;
                }
              } else {
                if( r_node_id == 0 ) {
                  ASSERT( l_node_id > 0 );
                  *(iter+1).l_node = l_node_id;
                }
              }
              keyInfos.erase(iter);
              break;
            }
          }

          if( r_node_id > 0 ){
            updateKeyInfos(r_node_id, new_key_infos);
            if( l_node_id > 0 ) {
              removeAllChildren( l_node_id );
              changePCRelation(myNodeId, l_node_id, REMOVE_OWNERSHIP);
            }
          } else if( l_node_id > 0 ){
            updateKeyInfos(l_node_id, new_key_infos);
          }
        }

      } // < MIN and > MAX
    } // is root
   
  } //async adjust 

  broadcast [BTreeNode<nodeId>] initializeBTreeNode( const uint32_t& nodeId, const uint32_t& pNodeId, const bool& r_flag, 
      const bool&  l_flag ) {
    
    myNodeId = nodeId;
    keyInfos.clear();
    
    parentId = pNodeId;
    root_flag = r_flag;
    leaf_flag = l_flag;
  }

  broadcast [BTreeNode<nodeId>] searchKeyInBTreeNode( const uint32_t& nodeId, const uint32_t& clientId, const int& key) {
    ADD_SELECTORS("BTreeApp");
    uint32_t i;
    uint32_t nextNodeId = 0;
    for(i=0; i<keyInfos.size(); i++) {
      if( keyInfos[i].key == key ) {
        replyClientRequest(clientId, key, keyInfos[i].value, nodeId, true);
        return;
      } else if( keyInfos[i].key > key ) {
        nextNodeId = keyInfos[i].l_node;
        break;
      }

      if( i+1 == keyInfos.size() && key > keyInfos[i].key ) {
        nextNodeId = keyInfos[i].r_node;
        break;
      }
    }

    if( nextNodeId > 0 ) {
      broadcast_searchKey( nextNodeId, clientId, key );
    } else {
      async_requestReply(clientId, key, 0, 0, true);
    }
  }

  async [BTreeNode<nodeId>] searchKeyDirect( const uint32_t& nodeId, const uint32_t& clientId, const int& key) {
    ADD_SELECTORS("BTreeApp");
    uint32_t i;
    for(i=0; i<keyInfos.size(); i++) {
      if( keyInfos[i].key == key ) {
        replyClientRequest(clientId, key, keyInfos[i].value, nodeId, true);
        break;
      } 
    }

    if( i == keyInfos.size() ) {
      async_searchKeyInBTree(clientId, key);
    }
  }

  broadcast [BTreeNode<nodeId>] scanKeyInBTreeNode( const uint32_t& nodeId, const uint32_t& clientId, const int& min_key, const int& max_key) {
    
  }

  broadcast [BTreeNode<nodeId>] insertKeyToBTreeNode( const uint32_t& nodeId, const uint32_t& clientId, const int& key, const int& value ) {
    ADD_SELECTORS("BTreeApp");
    mace::vector<KeyInfo>::iterator k_iter; 
    uint32_t nextNodeId = 0;
    uint32_t i = 0;
    for( k_iter = keyInfos.begin(); k_iter != keyInfos.end(); k_iter++, i++ ) {
      if( keyInfos[i].key == key ) {
        keyInfos[i].value = value;
        maceout<< "Replace key("<< key <<") in BTreeNode("<< nodeId <<")! key_size="<< keyInfos.size() << Log::endl;
        replyClientRequest(clientId, key, value, nodeId, true );
        return;
      } else if( keyInfos[i].key > key ) {
        nextNodeId = keyInfos[i].l_node;
        break;
      }

      if( i+1==keyInfos.size() && keyInfos[i].key < key ) {
        nextNodeId = keyInfos[i].r_node;
      }
    } 

    if(nextNodeId == 0) {
      KeyInfo newKey;
      newKey.key = key;
      newKey.value = value;
      newKey.l_node = 0;
      newKey.r_node = 0;
      if( k_iter == keyInfos.end() ) {
        keyInfos.push_back(newKey);
      } else {
        keyInfos.insert(k_iter, newKey);
      }
      maceout<< "Insert a new key("<< key <<") into BTreeNode("<< nodeId <<")! key_size="<< keyInfos.size() << Log::endl;
      if( keyInfos.size() > MAX_NKEY_PER_NODE ) {
        //maceout << "BTreeNode("<< nodeId<<") should be adjusted!"<< Log::endl;
        if( parentId == 0 ) {
          async_adjust(myNodeId, myNodeId);
        } else {
          async_adjust(parentId, myNodeId);
        }
      }
      
      replyClientRequest(clientId, key, value, myNodeId, true);
      
    } else {
      broadcast_insertKeyToBTreeNode(nextNodeId, clientId, key, value);
    }
  }

  async [BTreeNode<nodeId>] deleteKeyDirect( const uint32_t& nodeId, const uint32_t& clientId, const int& key ) {
    ADD_SELECTORS("BTreeApp");
    //maceout << "In BTreeNode("<< myNodeId <<") keyInfos=" << keyInfos << Log::endl;
    uint32_t nextNodeId = 0;
    mace::vector<KeyInfo>::iterator k_iter = keyInfos.begin();
    int tempKey = 0;
    for(; k_iter != keyInfos.end(); k_iter ++ ) {
      tempKey = (*k_iter).key;
      if( tempKey == key ) {
        break;
      } 
    } 

    if( tempKey == key ){
      uint32_t r_node = 0;
      uint32_t l_node = (*k_iter).l_node;
      if( k_iter+1 == keyInfos.end() ) {
        r_node = (*k_iter).r_node;
      } else {
        k_iter ++;
        r_node = (*k_iter).l_node;
        k_iter --;
      }
      if( r_node != 0 ) {
        KeyInfo new_key = removeMostLeftKeyFromBTree(r_node);
        if( new_key.key == 0 ){
          replyClientRequest(clientId, key, 100, 0, false);
          return;
        }
        maceout << "deleteKey: To replace key("<< (*k_iter).key <<") with key("<< new_key.key <<") in BTreeNode("<< myNodeId <<")!" << Log::endl;
        (*k_iter).key = new_key.key;
      } else if( l_node != 0 ) {
        KeyInfo new_key = removeMostRightKeyFromBTree(l_node);
        if( new_key.key == 0 ){
          //maceout << "deleteKey: try to delete key("<< key <<") again!" << Log::endl;        
          //async_deleteKeyFromBTree(clientId, key);
          replyClientRequest(clientId, key, 100, 0, false);
          return;
        }
        maceout << "deleteKey: To replace key("<< (*k_iter).key <<") with key("<< new_key.key <<") in BTreeNode("<< myNodeId <<")!" << Log::endl;
        (*k_iter).key = new_key.key;
      } else {
        maceout << "Delete key("<< key <<") from BTreeNode("<< myNodeId <<")!" << Log::endl;
        keyInfos.erase(k_iter);

        if( keyInfos.size() < MIN_NKEY_PER_NODE ) {
          maceout << "To adjust BTreeNode("<< myNodeId <<"). keyInfos=" << keyInfos << Log::endl;
          if( parentId ==0 ) async_adjust(myNodeId, myNodeId);
          else async_adjust(parentId, myNodeId);
        } 
      }
      replyClientRequest(clientId, key, 100, 0, true);
      return;
    } else {
      async_deleteKeyFromBTree(clientId, key);
    }
  }

  broadcast [BTreeNode<nodeId>] deleteKeyFromBTreeNode( const uint32_t& nodeId, const uint32_t& clientId, const int& key ) {
    ADD_SELECTORS("BTreeApp");
    //maceout << "In BTreeNode("<< myNodeId <<") keyInfos=" << keyInfos << Log::endl;
    uint32_t nextNodeId = 0;
    mace::vector<KeyInfo>::iterator k_iter = keyInfos.begin();
    int tempKey = 0;
    for(; k_iter != keyInfos.end(); k_iter ++ ) {
      tempKey = (*k_iter).key;
      if( tempKey == key ) {
        break;
      } else if( tempKey > key ) {
        nextNodeId = (*k_iter).l_node;
        break;
      }

      if( k_iter+1 == keyInfos.end() && key > tempKey ) {
        nextNodeId = (*k_iter).r_node;
      } 
    } 

    if( tempKey == key ){
      uint32_t r_node = 0;
      uint32_t l_node = (*k_iter).l_node;
      if( k_iter+1 == keyInfos.end() ) {
        r_node = (*k_iter).r_node;
      } else {
        k_iter ++;
        r_node = (*k_iter).l_node;
        k_iter --;
      }
      if( r_node != 0 ) {
        KeyInfo new_key = removeMostLeftKeyFromBTree(r_node);
        if( new_key.key == 0 ){
          replyClientRequest(clientId, key, 100, 0, false);
          return;
        }
        maceout << "deleteKey: To replace key("<< (*k_iter).key <<") with key("<< new_key.key <<") in BTreeNode("<< myNodeId <<")!" << Log::endl;
        (*k_iter).key = new_key.key;
      } else if( l_node != 0 ) {
        KeyInfo new_key = removeMostRightKeyFromBTree(l_node);
        if( new_key.key == 0 ){
          //maceout << "deleteKey: try to delete key("<< key <<") again!" << Log::endl;        
          //async_deleteKeyFromBTree(clientId, key);
          replyClientRequest(clientId, key, 100, 0, false);
          return;
        }
        maceout << "deleteKey: To replace key("<< (*k_iter).key <<") with key("<< new_key.key <<") in BTreeNode("<< myNodeId <<")!" << Log::endl;
        (*k_iter).key = new_key.key;
      } else {
        maceout << "Delete key("<< key <<") from BTreeNode("<< myNodeId <<")!" << Log::endl;
        keyInfos.erase(k_iter);

        if( keyInfos.size() < MIN_NKEY_PER_NODE ) {
          maceout << "To adjust BTreeNode("<< myNodeId <<"). keyInfos=" << keyInfos << Log::endl;
          if( parentId ==0 ) async_adjust(myNodeId, myNodeId);
          else async_adjust(parentId, myNodeId);
        } 
      }
      replyClientRequest(clientId, key, 100, 0, true);
      return;
    }
      
    if( nextNodeId != 0 ) {
      broadcast_deleteKeyFromBTreeNode(nextNodeId, clientId, key);
    } else {
      maceout << "Fail to find key("<< key <<") in BTree!" << Log::endl;
    }
  }

}

routines {

  [__null] mace::string generateContextName( const mace::string& ctxName, const uint32_t& id) {
    std::ostringstream oss;
    oss << ctxName <<"["<<id<<"]";
    return oss.str();
  }

  

[BTreeNode<nodeId>] void initializeBTreeNode2( const uint32_t& nodeId, const uint32_t& pNodeId, const bool& r_flag, 
    const mace::vector<KeyInfo>& k_infos ) {
  
  ADD_SELECTORS("BTreeApp");
  myNodeId = nodeId;
  keyInfos.clear();
    
  parentId = pNodeId;
  root_flag = r_flag;
  leaf_flag = true;

  keyInfos = k_infos;

  mace::vector<uint32_t> childNodeIds = getValidChildIDs( keyInfos );

  for( uint32_t i=0; i<childNodeIds.size(); i++ ){
    changePCRelation(myNodeId, childNodeIds[i], CREATE_OWNERSHIP);
  }

  for( uint32_t i=0; i<childNodeIds.size(); i++ ){
    setParentNodeId(childNodeIds[i], myNodeId);
  }
  maceout << "initializeBTreeNode2 BTreeNode("<< myNodeId <<") keyInfos=" <<keyInfos<< Log::endl;
}

[BTreeNode<nodeId>] uint32_t getKeySize( const uint32_t& nodeId) {
  return keyInfos.size();
}

[BTreeNode<nodeId>] KeyInfo removeMostRightKeyFromBTree(const uint32_t& nodeId) {
  ADD_SELECTORS("BTreeApp");
  if( keyInfos.size() > 0 ) {
    mace::vector<KeyInfo>::iterator iter = keyInfos.begin();
    while( iter+1 != keyInfos.end() ) {
      iter ++;
    }

    KeyInfo keyInfo = *iter;
    uint32_t r_node = keyInfo.r_node;
    uint32_t l_node = keyInfo.l_node;
    if( r_node == 0 ) {
      if( keyInfos.size() == 1 ) {
        if( l_node != 0 ) {
          KeyInfo newKeyInfo = removeMostRightKeyFromBTree(l_node);
          if( newKeyInfo.key == 0 ) {
            return newKeyInfo;
          }
          /*
          maceout << "removeMostRightKeyFromBTree: To replace key("<< keyInfo.key <<") with key("<< newKeyInfo.key <<") in BTreeNode("<< myNodeId <<")!" << Log::endl;
          */
          (*iter).key = newKeyInfo.key;
          return keyInfo; 
        } else { // l_node = r_node = 0
          keyInfos.erase(iter);
          //maceout << "removeMostRightKeyFromBTree: To remove key("<< keyInfo.key <<") from BTreeNode("<< myNodeId <<")!" << Log::endl;
        }
      } else {
        KeyInfo& l_sibling_keyInfo = keyInfos[ keyInfos.size() - 2 ];
        l_sibling_keyInfo.r_node = keyInfo.l_node;
        keyInfos.erase(iter);
        // maceout << "removeMostRightKeyFromBTree: To remove key("<< keyInfo.key <<") from BTreeNode("<< myNodeId <<")!" << Log::endl;
      }
    } else {
      return removeMostRightKeyFromBTree(r_node);
    }
    
    if( keyInfos.size() < MIN_NKEY_PER_NODE ) {
      // maceout << "To adjust BTreeNode("<< myNodeId <<"). keyInfos="<< keyInfos << Log::endl;
      if( parentId ==0) async_adjust(myNodeId, myNodeId);
      else async_adjust(parentId, myNodeId);
    }
    return keyInfo;
  } else {
    // maceout << "removeMostRightKeyFromBTree: something wrong in BTreeNode("<< myNodeId <<")!" << Log::endl;
    KeyInfo keyInfo;
    keyInfo.key = 0;
    return keyInfo;
  }
}

[BTreeNode<nodeId>] KeyInfo removeMostLeftKeyFromBTree(const uint32_t& nodeId) {
  ADD_SELECTORS("BTreeApp");
  if( keyInfos.size() > 0 ) {
    mace::vector<KeyInfo>::iterator iter = keyInfos.begin();
    KeyInfo keyInfo = *iter;
    uint32_t r_node = 0;
    uint32_t l_node = keyInfo.l_node;

    if( keyInfos.size() == 1 ){
      r_node = keyInfo.r_node;
    } else{
      r_node = keyInfos[1].l_node;
    }

    if( l_node == 0 ) {
      if( keyInfos.size() == 1 ) {
        if( r_node != 0 ) {
          KeyInfo newKeyInfo = removeMostLeftKeyFromBTree(r_node);
          if( newKeyInfo.key == 0 ){
            return newKeyInfo;
          }
          (*iter).key = newKeyInfo.key;
          /*
          maceout << "removeMostLeftKeyFromBTree: To replace key("<< keyInfo.key <<") with key("<< newKeyInfo.key <<") in BTreeNode("<< myNodeId <<")!" << Log::endl;
          */
        } else {
          keyInfos.erase(iter);
          //maceout << "removeMostLeftKeyFromBTree: To remove key("<< keyInfo.key <<") from BTreeNode("<< myNodeId <<")!" << Log::endl;
        }
      } else {
        keyInfos.erase(iter);
        //maceout << "removeMostLeftKeyFromBTree: To remove key("<< keyInfo.key <<") from BTreeNode("<< myNodeId <<")!" << Log::endl;
      }
    } else {
      return removeMostLeftKeyFromBTree(l_node);
    }
    
    if( keyInfos.size() < MIN_NKEY_PER_NODE ) {
      //maceout << "To adjust BTreeNode("<< myNodeId <<") keyInfos=" << keyInfos << Log::endl;
      if( parentId ==0) async_adjust(myNodeId, myNodeId);
      else async_adjust(parentId, myNodeId);
    }
    return keyInfo;
  } else {
    //maceout << "removeMostLeftKeyFromBTree: something wrong in BTreeNode("<< myNodeId <<")!" << Log::endl;
    KeyInfo keyInfo;
    keyInfo.key = 0;
    return keyInfo;
  }
}


[BTreeNode<nodeId>] KeyInfo removeMostLeftKey(const uint32_t& nodeId) {
  ADD_SELECTORS("BTreeApp");
  //maceout << "Before removeMostLeftKey BTreeNode("<< myNodeId <<"): keyInfos = " << keyInfos << Log::endl;
  KeyInfo keyInfo = keyInfos[0];
  keyInfos.erase( keyInfos.begin() );

  uint32_t nId = keyInfo.l_node;
  if( nId > 0 ) {
    changePCRelation( myNodeId, nId, REMOVE_OWNERSHIP);
  }
  //maceout << "After removeMostLeftKey BTreeNode("<< myNodeId <<"): keyInfos = " << keyInfos << Log::endl;
  return keyInfo;
}

[BTreeNode<nodeId>] void addMostRightKey(const uint32_t& nodeId, const KeyInfo& newKeyInfo) {
  ADD_SELECTORS("BTreeApp");
  //maceout << "Before addMostRightKey BTreeNode("<< myNodeId <<"): keyInfos = " << keyInfos << Log::endl;
  KeyInfo& keyInfo = keyInfos[keyInfos.size()-1];
  KeyInfo newKey = newKeyInfo;
  newKey.l_node = keyInfo.r_node;
  keyInfos.push_back(newKeyInfo);

  uint32_t nId = newKeyInfo.r_node;
  if( nId > 0 ) {
    changePCRelation( myNodeId, nId, CREATE_OWNERSHIP);
  }
  //maceout << "After addMostRightKey BTreeNode("<< myNodeId <<"): keyInfos = " << keyInfos << Log::endl;
}

[BTreeNode<nodeId>] KeyInfo removeMostRightKey(const uint32_t& nodeId) {
  ADD_SELECTORS("BTreeApp");
  //maceout << "Before removeMostRightKey BTreeNode("<< myNodeId <<"): keyInfos = " << keyInfos << Log::endl;
  KeyInfo rKeyInfo = keyInfos[keyInfos.size()-1];
  keyInfos.pop_back();
  KeyInfo& keyInfo = keyInfos[keyInfos.size()-1];
  keyInfo.r_node = rKeyInfo.l_node;

  uint32_t nId = rKeyInfo.r_node;
  if( nId > 0 ) {
    changePCRelation( myNodeId, nId, REMOVE_OWNERSHIP);
  }
  //maceout << "After removeMostRightKey BTreeNode("<< myNodeId <<"): keyInfos = " << keyInfos << Log::endl;
  return rKeyInfo;
}

[BTreeNode<nodeId>] void addMostLeftKey(const uint32_t& nodeId, const KeyInfo& newKeyInfo) {
  ADD_SELECTORS("BTreeApp");
  //maceout << "Before addMostLeftKey BTreeNode("<< myNodeId <<"): keyInfos = " << keyInfos << Log::endl;
  keyInfos.insert( keyInfos.begin(), newKeyInfo );

  uint32_t nId = newKeyInfo.l_node;
  if( nId > 0 ) {
    changePCRelation( myNodeId, nId, CREATE_OWNERSHIP);
  }
  //maceout << "After addMostLeftKey BTreeNode("<< myNodeId <<"): keyInfos = " << keyInfos << Log::endl;
}

[BTreeNode<nodeId>] void addMostRightKeys(const uint32_t& nodeId, const mace::vector<KeyInfo>& newKeyInfos) {
  ADD_SELECTORS("BTreeApp");
  //maceout << "Before addMostRightKeys BTreeNode("<< myNodeId <<"): keyInfos = " << keyInfos << Log::endl;
  KeyInfo& keyInfo = keyInfos[keyInfos.size()-1];

  for(uint32_t i=0; i<newKeyInfos.size(); i++ ) {
    KeyInfo tmp_key = newKeyInfos[i];
    if( i== 0 ){
      tmp_key.l_node = keyInfo.r_node;
      keyInfo.r_node = 0;
    } else {
      uint32_t nId = tmp_key.l_node;
      if( nId > 0 ) {
        changePCRelation( myNodeId, nId, CREATE_OWNERSHIP);
      }
    }

    if( i == newKeyInfos.size() - 1 ) {
      uint32_t nId = tmp_key.r_node;
      if( nId > 0 ) {
        changePCRelation( myNodeId, nId, CREATE_OWNERSHIP);
      }
    }
    keyInfos.push_back(tmp_key);
  }
  
  //maceout << "After addMostRightKeys BTreeNode("<< myNodeId <<"): keyInfos = " << keyInfos << Log::endl;
}

[BTreeNode<nodeId>] void addMostLeftKeys(const uint32_t& nodeId, const mace::vector<KeyInfo>& newKeyInfos) {
  ADD_SELECTORS("BTreeApp");
  //maceout << "Before addMostLeftKeys BTreeNode("<< myNodeId <<"): keyInfos = " << keyInfos << Log::endl;
  
  for(uint32_t i=0; i<newKeyInfos.size(); i++ ) {
    const KeyInfo& tmp_key = newKeyInfos[i];
    uint32_t nId = tmp_key.l_node;
    if( nId > 0 ) {
      changePCRelation( myNodeId, nId, CREATE_OWNERSHIP);
    }

    if( i == newKeyInfos.size() - 1 ) {
      uint32_t nId = tmp_key.r_node;
      if( nId > 0 ) {
        changePCRelation( myNodeId, nId, CREATE_OWNERSHIP);
      }
    }
  }

  mace::vector<KeyInfo> new_keyInfos = newKeyInfos;

  for(uint32_t i=0; i<keyInfos.size(); i++ ) {
    new_keyInfos.push_back(keyInfos[i]);
  }
  keyInfos = new_keyInfos;
  //maceout << "After addMostRightKeys BTreeNode("<< myNodeId <<"): keyInfos = " << keyInfos << Log::endl;
}

[BTreeNode<nodeId>] mace::vector<KeyInfo> splitLeftKeys(const uint32_t& nodeId) {
  uint32_t mid = (uint32_t)( keyInfos.size() / 2 );
  mace::vector<KeyInfo> remain_keys;
  mace::vector<KeyInfo> l_keys;
  for(uint32_t i=0; i<keyInfos.size(); i++) {
    if( i<=mid ) {
      l_keys.push_back( keyInfos[i] );
    } else {
      remain_keys.push_back( keyInfos[i] );
    }
  }

  keyInfos = remain_keys;
  return l_keys;
}

[BTreeNode<nodeId>] mace::vector<KeyInfo> getKeys(const uint32_t& nodeId) {
  return keyInfos;
}

[BTreeNode<nodeId>] void removeAllChildren(const uint32_t& nodeId) {
  ADD_SELECTORS("BTreeApp");
  //maceout << "To remove all children of BTreeNode("<< myNodeId <<") keyInfos=" << keyInfos << Log::endl;
  leaf_flag = true;
  for(uint32_t i=0; i<keyInfos.size(); i++) {
    uint32_t nId = keyInfos[i].l_node;
    if( nId > 0 ) {
      changePCRelation( myNodeId, nId, REMOVE_OWNERSHIP);
    }

    if( i+1 == keyInfos.size() ) {
      nId = keyInfos[i].r_node;
      if( nId > 0 ) {
        changePCRelation( myNodeId, nId, REMOVE_OWNERSHIP);
      }
    }
  }
}

[BTreeNode<nodeId>] void setParentNodeId(const uint32_t nodeId, const uint32_t& pId) {
  ADD_SELECTORS("BTreeApp");
  parentId = pId;
  //maceout << "Set BTreeNode("<< myNodeId <<") parentId=" << parentId << Log::endl;
}

[BTreeNode<nodeId] void removeChildrenInChildNode( const uint32_t& nodeId, const mace::vector<uint32_t>& childNodeIds ) {
  for(uint32_t i=0; i<childNodeIds.size(); i++) {
    changePCRelation( myNodeId, childNodeIds[i], REMOVE_OWNERSHIP);
  }
}

[BTreeNode<nodeId>] void updateKeyInfos( const uint32_t& nodeId, const mace::vector<KeyInfo>& new_key_infos) {
  mace::vector<uint32_t> childIds = getValidChildIDs( new_key_infos );
  for( uint32_t i=0; i<childIds.size(); i++ ) {
    changePCRelation( nodeId, childIds[i], CREATE_OWNERSHIP );
  }

  keyInfos = new_key_infos;
}

[__null] bool checkParentChild( mace::vector<KeyInfo> const& keyInfos, uint32_t const& childId ) {
  for(uint32_t i = 0; i<keyInfos.size(); i++ ) {
    if( keyInfos[i].l_node == childId ) {
      return true;
    }

    if( i+1 == keyInfos.size() && keyInfos[i].r_node == childId ) {
      return true;
    }
  }
  return false;
}

[__null] void split(const std::string& s, char c, std::vector<std::string>& v) {
  std::string::size_type i = 0;
  std::string::size_type j = s.find(c);

  while (j != std::string::npos) {
    v.push_back(s.substr(i, j-i));
    i = ++j;
    j = s.find(c, j);

    if (j == std::string::npos) {
      v.push_back(s.substr(i, s.length()));
    }
  }
}

[__null] void changePCRelation( const uint32_t& pNodeId, const uint32_t& cNodeId, const uint32_t& op) {
  mace::string p_contextName = generateContextName("BTreeNode", pNodeId);
  mace::string c_contextName = generateContextName("BTreeNode", cNodeId);
  if( op == CREATE_OWNERHSHIP ){
    createNewOwnership(p_contextName, c_contextName );
  } else if ( op == REMOVE_OWNERSHIP ){
    removeOwnership(p_contextName, c_contextName);
  }
}

[__null] void addChildNodes( const uint32_t& pNodeId, const mace::vector<uint32_t>& childNodeIds ) {
  for(uint32_t i=0; i<childNodeIds.size(); i++) {
    changePCRelation(pNodeId, childNodeIds[i], CREATE_OWNERSHIP);
  }
}
 
[__null] mace::vector<uint32_t> getValidChildIDs( const mace::vector<KeyInfo>& keyInfos) {
  mace::vector<uint32_t> childIds;
  for( uint32_t i=0; i<keyInfos.size(); i++ ) {
    if( keyInfos[i].l_node > 0 ){
      childIds.push_back( keyInfos[i].l_node );
    }
    if( i == keyInfos.size()-1 && keyInfos[i].r_node>0 ){
      childIds.push_back( keyInfos[i].r_node );
    }
  }
  return childIds;
}

[__null] void replyClientRequest(const uint32_t& clientId, const int& key, const int& value, const uint32_t& nodeId, const bool& succ) {
  mace::vector< mace::pair<int, int> > keyValues;
  mace::pair<int, int> keyValue(key, value);
  keyValues.push_back(keyValue);
  async_requestReply(clientId, keyValues, nodeId, succ);
} 

}

