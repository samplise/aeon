CMAKE_MINIMUM_REQUIRED(VERSION 2.4)
IF(COMMAND cmake_policy)
  CMAKE_POLICY(SET CMP0003 NEW)
ENDIF(COMMAND cmake_policy)

PROJECT(Mace)
ENABLE_TESTING()

OPTION(USE_GPROF "Whether to build Mace with gprof library" off)
IF(USE_GPROF)
  SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pg")
ENDIF(USE_GPROF)


IF(${Mace_SOURCE_DIR} STREQUAL ${Mace_BINARY_DIR})
  MESSAGE(FATAL_ERROR "Must not build Mace in its source dir.  Try configuring in a builds directory")
ENDIF(${Mace_SOURCE_DIR} STREQUAL ${Mace_BINARY_DIR})

FIND_PACKAGE(Perl REQUIRED)
FIND_PACKAGE(Boost COMPONENTS unit_test_framework REQUIRED)
FIND_PACKAGE(OpenSSL REQUIRED)

INCLUDE_DIRECTORIES(${Boost_INCLUDE_DIRS})
LINK_DIRECTORIES(${Boost_LIBRARY_DIRS})

INCLUDE_DIRECTORIES(${OPENSSL_INCLUDE_DIR})

#OPTION(USE_TOKYO_CABINET "Enable support for Maps backed by Tokyo Cabinet" off)

#FIND_LIBRARY(LIB_RT rt)
FIND_LIBRARY(LIB_TOKYO_CABINET tokyocabinet)
FIND_LIBRARY(LIB_DL dl)
FIND_LIBRARY(LIB_Z z)
IF(LIB_TOKYO_CABINET)
  SET(HAVE_TOKYO_CABINET 1)  
ENDIF(LIB_TOKYO_CABINET)

FIND_PATH(GSL_INC_PATH gsl/gsl_cdf.h)
INCLUDE_DIRECTORIES(${GSL_INC_PATH})
FIND_LIBRARY(LIB_GSL gsl)
FIND_LIBRARY(LIB_GSLCBLAS gslcblas)
IF(LIB_GSL AND LIB_GSLCBLAS)
  SET(HAVE_GSL 1)  
ENDIF(LIB_GSL AND LIB_GSLCBLAS)

FIND_PATH(DB_CXX_INC_PATH db_cxx.h)
IF(EXISTS ${DB_CXX_INC_PATH})
  INCLUDE_DIRECTORIES(SYSTEM ${DB_CXX_INC_PATH})
ELSE(EXISTS ${DB_CXX_INC_PATH})
  MESSAGE("WARNING: Cannot find db_cxx.h.  Will not be able to use mdb, Map, etc.")
  SET(SHARED_DEFINITIONS ${SHARED_DEFINITIONS} -DNO_DB_CXX)
ENDIF(EXISTS ${DB_CXX_INC_PATH})

FIND_PATH(HDFS_INC_PATH hdfs.h)
IF(EXISTS ${HDFS_INC_PATH})
  INCLUDE_DIRECTORIES(SYSTEM ${HDFS_INC_PATH})
ELSE(EXISTS ${HDFS_INC_PATH})
  MESSAGE("WARNING: Cannot find hdfs.h.  Will not be able to use HDFS client library")
ENDIF(EXISTS ${HDFS_INC_PATH})

INCLUDE (${CMAKE_ROOT}/Modules/CheckIncludeFile.cmake) 
#CHECK_INCLUDE_FILE("unistd.h" HAVE_UNISTD_H)
#CHECK_INCLUDE_FILE("sys/time.h" HAVE_SYS_TIME_H)
CHECK_INCLUDE_FILE("netinet/in.h" HAVE_NETINET_IN_H)
CHECK_INCLUDE_FILE("netinet/tcp.h" HAVE_NETINET_TCP_H)
CHECK_INCLUDE_FILE("netdb.h" HAVE_NETDB_H)
CHECK_INCLUDE_FILE("sys/select.h" HAVE_SYS_SELECT_H)
CHECK_INCLUDE_FILE("sys/socket.h" HAVE_SYS_SOCKET_H)
CHECK_INCLUDE_FILE("sys/wait.h" HAVE_SYS_WAIT_H)
CHECK_INCLUDE_FILE("arpa/inet.h" HAVE_ARPA_INET_H)

FIND_PATH(PTHREAD_PATH pthread.h)
INCLUDE_DIRECTORIES(${PTHREAD_PATH})

INCLUDE(CheckFunctionExists)
CHECK_FUNCTION_EXISTS(drand48 HAVE_DRAND48)
CHECK_FUNCTION_EXISTS(rand_s HAVE_RAND_S)
CHECK_FUNCTION_EXISTS(rand HAVE_RAND)
CHECK_FUNCTION_EXISTS(waitpid HAVE_WAITPID)
CHECK_FUNCTION_EXISTS(_cwait HAVE__CWAIT)

CHECK_FUNCTION_EXISTS(fcntl HAVE_FCNTL)
CHECK_FUNCTION_EXISTS(sigaction HAVE_SIGACTION)
CHECK_FUNCTION_EXISTS(getppid HAVE_GETPPID)

CHECK_FUNCTION_EXISTS(pipe HAVE_PIPE)
CHECK_FUNCTION_EXISTS(_pipe HAVE__PIPE)
IF(NOT HAVE_PIPE AND NOT HAVE__PIPE)
  MESSAGE(SEND_ERROR "Cannot find pipe() implementation.  Looking either for pipe() or _pipe().")
ENDIF(NOT HAVE_PIPE AND NOT HAVE__PIPE)

CHECK_FUNCTION_EXISTS(mkstemp HAVE_MKSTEMP)

INCLUDE(CheckLibraryExists)
CHECK_LIBRARY_EXISTS(c regcomp /usr/lib LIBC_HAS_REGEX)
CHECK_LIBRARY_EXISTS(c setsockopt /usr/lib LIBC_HAS_SETSOCKOPT)

INCLUDE(CheckTypeSize)
SET(CMAKE_EXTRA_INCLUDE_FILES unistd.h sys/types.h netinet/in.h sys/select.h)
CHECK_TYPE_SIZE(useconds_t USECONDS_T)
CHECK_TYPE_SIZE(suseconds_t SUSECONDS_T)
CHECK_TYPE_SIZE(uint UINT)
CHECK_TYPE_SIZE(in_addr_t IN_ADDR_T)

IF(UNIX)
SET(SIGNED_SOCKET 1)
SET(INCLUDE_CGI 1)
ELSE(UNIX)
SET(WINDOWS_FILES 1)
ENDIF(UNIX)

SET(MACEC_FLAGS "" CACHE STRING "Extra flags to pass to the macec compiler")

OPTION(USE_SHARED "Whether to build Mace with shared libraries" off)
IF(USE_SHARED)
  SET(LIBTYPE SHARED)
ELSE(USE_SHARED)
  SET(LIBTYPE STATIC)
ENDIF(USE_SHARED)

OPTION(CONDOR "Link executables statically. Required if running on Condor")

IF(CONDOR)
    SET(CMAKE_EXE_LINKER_FLAGS "-static")
    SET(LINK_SEARCH_END_STATIC ON)
ENDIF(CONDOR)

OPTION(USE_SNAPSHOT "Whether to use InContext snapshot optimization. Otherwise, RW Lock will be used." on)

SET(EXTERNAL_VARS_FILE ${Mace_BINARY_DIR}/MaceConfig.cmake)

IF(APPLE)
  MESSAGE("NOTE: Using stupid FD_SET const-cast hack on apple system")
  MESSAGE("NOTE: Setting EINVAL_IS_NOTCONN")
  MESSAGE("NOTE: Setting OSX_MACELIB_DAEMON")
  MESSAGE("NOTE: Setting OSX_SCHED_YIELD")
  SET(EINVAL_IS_NOTCONN 1)
  SET(STUPID_FD_SET_CONST_HACK 1)
  SET(OSX_MACELIB_DAEMON 1)
  SET(OSX_SCHED_YIELD 1)
  #ADD_DEFINITIONS(-DSTUPID_FD_SET_CONST_HACK -DEINVAL_IS_NOTCONN)
ENDIF(APPLE)

SET(APPLICATION_SUBDIR "application")

TRY_COMPILE(UINT64T_IS_NOT_ULONGLONG ${CMAKE_CURRENT_BINARY_DIR}/cmake_tests/ ${CMAKE_CURRENT_SOURCE_DIR}/cmake_tests/uint64_is_ulonglong.cc)

INCLUDE_DIRECTORIES(${Mace_BINARY_DIR})
CONFIGURE_FILE(${Mace_SOURCE_DIR}/maceConfig.h.in ${Mace_BINARY_DIR}/maceConfig.h)

WRITE_FILE(${EXTERNAL_VARS_FILE} "#Mace Configuration File")
WRITE_FILE(${EXTERNAL_VARS_FILE} "SET(Mace_SOURCE_DIR \"${Mace_SOURCE_DIR}\")" APPEND)
WRITE_FILE(${EXTERNAL_VARS_FILE} "SET(Mace_BINARY_DIR \"${Mace_BINARY_DIR}\")" APPEND)
#WRITE_FILE(${EXTERNAL_VARS_FILE} "INCLUDE_DIRECTORIES(${OPENSSL_INCLUDE_DIR})" APPEND)
#WRITE_FILE(${EXTERNAL_VARS_FILE} "INCLUDE_DIRECTORIES(${Boost_INCLUDE_DIRS})" APPEND)
#WRITE_FILE(${EXTERNAL_VARS_FILE} "LINK_DIRECTORIES(${Boost_LIBRARY_DIRS})" APPEND)
WRITE_FILE(${EXTERNAL_VARS_FILE} "SET(DB_CXX_INC_PATH \"${DB_CXX_INC_PATH}\")" APPEND)
#WRITE_FILE(${EXTERNAL_VARS_FILE} "INCLUDE_DIRECTORIES(${PTHREAD_PATH})" APPEND)

#CK Concern -- not sure how to make -Wall and -Werror be generic to other build
#systems.  Isn't CMAKE supposed to make this easy?  Sure -- I could do it with
#an IF(WIN32) or some such, but that's not that much easier IMO
SET(SHARED_DEFINITIONS ${SHARED_DEFINITIONS} -D__STDC_FORMAT_MACROS -D_FILE_OFFSET_BITS=64)
ADD_DEFINITIONS(-Wall -Werror ${SHARED_DEFINITIONS})
WRITE_FILE(${EXTERNAL_VARS_FILE} "ADD_DEFINITIONS(${SHARED_DEFINITIONS})" APPEND)

ADD_SUBDIRECTORY(lib)
ADD_SUBDIRECTORY(tools EXCLUDE_FROM_ALL)
ADD_SUBDIRECTORY(perl5)
ADD_SUBDIRECTORY(services)
ADD_SUBDIRECTORY(application)

WRITE_FILE(${EXTERNAL_VARS_FILE} "
#Top level properties" APPEND)

GET_DIRECTORY_PROPERTY(TOP_INC_D INCLUDE_DIRECTORIES)
WRITE_FILE(${EXTERNAL_VARS_FILE} "INCLUDE_DIRECTORIES(SYSTEM ${TOP_INC_D})" APPEND)

GET_DIRECTORY_PROPERTY(TOP_LINK_D LINK_DIRECTORIES)
WRITE_FILE(${EXTERNAL_VARS_FILE} "LINK_DIRECTORIES(${TOP_LINK_D})" APPEND)

IF(LIBRARY_OUTPUT_PATH)
  WRITE_FILE(${EXTERNAL_VARS_FILE} "
#Libraries we generated were placed here" APPEND)
  WRITE_FILE(${EXTERNAL_VARS_FILE} "LINK_DIRECTORIES(${LIBRARY_OUTPUT_PATH})" APPEND)
ENDIF(LIBRARY_OUTPUT_PATH)

WRITE_FILE(${EXTERNAL_VARS_FILE} "
#Library dependency information" APPEND)
EXPORT_LIBRARY_DEPENDENCIES(${EXTERNAL_VARS_FILE} APPEND)
